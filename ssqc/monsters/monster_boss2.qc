
$frame boss2_base

$frame boss2_idle1 boss2_idle2 boss2_idle3 boss2_idle4 boss2_idle5 boss2_idle6 boss2_idle7 boss2_idle8 boss2_idle9 boss2_idle10
$frame boss2_idle11 boss2_idle12 boss2_idle13 boss2_idle14 boss2_idle15 boss2_idle16 boss2_idle17 boss2_idle18 boss2_idle19 boss2_idle20
$frame boss2_idle21 boss2_idle22 boss2_idle23 boss2_idle24 boss2_idle25 boss2_idle26 boss2_idle27 boss2_idle28 boss2_idle29 boss2_idle30
$frame boss2_idle31 boss2_idle32 boss2_idle33 boss2_idle34 boss2_idle35 boss2_idle36 boss2_idle37 boss2_idle38 boss2_idle39 boss2_idle40

$frame boss2_wakeup1 boss2_wakeup2 boss2_wakeup3 boss2_wakeup4 boss2_wakeup5 boss2_wakeup6 boss2_wakeup7 boss2_wakeup8 boss2_wakeup9 boss2_wakeup10
$frame boss2_wakeup11 boss2_wakeup12 boss2_wakeup13 boss2_wakeup14 boss2_wakeup15 boss2_wakeup16 boss2_wakeup17 boss2_wakeup18 boss2_wakeup19 boss2_wakeup20
$frame boss2_wakeup21 boss2_wakeup22 boss2_wakeup23 boss2_wakeup24 boss2_wakeup25 boss2_wakeup26 boss2_wakeup27 boss2_wakeup28 boss2_wakeup29 boss2_wakeup30
$frame boss2_wakeup31 boss2_wakeup32 boss2_wakeup33 boss2_wakeup34 boss2_wakeup35 boss2_wakeup36 boss2_wakeup37 boss2_wakeup38 boss2_wakeup39 boss2_wakeup40
$frame boss2_wakeup41 boss2_wakeup42 boss2_wakeup43 boss2_wakeup44 boss2_wakeup45 boss2_wakeup46 boss2_wakeup47 boss2_wakeup48 boss2_wakeup49 boss2_wakeup50
$frame boss2_wakeup51 boss2_wakeup52 boss2_wakeup53 boss2_wakeup54 boss2_wakeup55 boss2_wakeup56 boss2_wakeup57 boss2_wakeup58 boss2_wakeup59 boss2_wakeup60

$frame boss2_hovera1 boss2_hovera2 boss2_hovera3 boss2_hovera4 boss2_hovera5 boss2_hovera6 boss2_hovera7 boss2_hovera8 boss2_hovera9 boss2_hovera10
$frame boss2_hovera11 boss2_hovera12 boss2_hovera13 boss2_hovera14 boss2_hovera15 boss2_hovera16 boss2_hovera17 boss2_hovera18 boss2_hovera19 boss2_hovera20
$frame boss2_hovera21 boss2_hovera22 boss2_hovera23 boss2_hovera24 boss2_hovera25 boss2_hovera26 boss2_hovera27 boss2_hovera28 boss2_hovera29 boss2_hovera30

$frame boss2_pain1 boss2_pain2 boss2_pain3 boss2_pain4 boss2_pain5 boss2_pain6 boss2_pain7 boss2_pain8 boss2_pain9 boss2_pain10

$frame boss2_scowl1 boss2_scowl2 boss2_scowl3 boss2_scowl4 boss2_scowl5 boss2_scowl6 boss2_scowl7 boss2_scowl8 boss2_scowl9 boss2_scowl10
$frame boss2_scowl11 boss2_scowl12 boss2_scowl13 boss2_scowl14 boss2_scowl15 boss2_scowl16 boss2_scowl17 boss2_scowl18 boss2_scowl19 boss2_scowl20
$frame boss2_scowl21 boss2_scowl22 boss2_scowl23 boss2_scowl24 boss2_scowl25

$frame boss2_hoverb1 boss2_hoverb2 boss2_hoverb3 boss2_hoverb4 boss2_hoverb5 boss2_hoverb6 boss2_hoverb7 boss2_hoverb8 boss2_hoverb9 boss2_hoverb10
$frame boss2_hoverb11 boss2_hoverb12 boss2_hoverb13 boss2_hoverb14 boss2_hoverb15 boss2_hoverb16 boss2_hoverb17 boss2_hoverb18 boss2_hoverb19 boss2_hoverb20
$frame boss2_hoverb21 boss2_hoverb22 boss2_hoverb23 boss2_hoverb24 boss2_hoverb25 boss2_hoverb26 boss2_hoverb27 boss2_hoverb28 boss2_hoverb29 boss2_hoverb30

$frame boss2_sstrf_l1 boss2_sstrf_l2 boss2_sstrf_l3 boss2_sstrf_l4 boss2_sstrf_l5 boss2_sstrf_l6 boss2_sstrf_l7 boss2_sstrf_l8 boss2_sstrf_l9 boss2_sstrf_l10
$frame boss2_sstrf_l11 boss2_sstrf_l12 boss2_sstrf_l13 boss2_sstrf_l14 boss2_sstrf_l15 boss2_sstrf_l16 boss2_sstrf_l17 boss2_sstrf_l18 boss2_sstrf_l19 boss2_sstrf_l20
$frame boss2_sstrf_l21 boss2_sstrf_l22 boss2_sstrf_l23 boss2_sstrf_l24 boss2_sstrf_l25 boss2_sstrf_l26 boss2_sstrf_l27 boss2_sstrf_l28 boss2_sstrf_l29 boss2_sstrf_l30

$frame boss2_sstrf_r1 boss2_sstrf_r2 boss2_sstrf_r3 boss2_sstrf_r4 boss2_sstrf_r5 boss2_sstrf_r6 boss2_sstrf_r7 boss2_sstrf_r8 boss2_sstrf_r9 boss2_sstrf_r10
$frame boss2_sstrf_r11 boss2_sstrf_r12 boss2_sstrf_r13 boss2_sstrf_r14 boss2_sstrf_r15 boss2_sstrf_r16 boss2_sstrf_r17 boss2_sstrf_r18 boss2_sstrf_r19 boss2_sstrf_r20
$frame boss2_sstrf_r21 boss2_sstrf_r22 boss2_sstrf_r23 boss2_sstrf_r24 boss2_sstrf_r25 boss2_sstrf_r26 boss2_sstrf_r27 boss2_sstrf_r28 boss2_sstrf_r29 boss2_sstrf_r30

$frame boss2_asstrf_l1 boss2_asstrf_l2 boss2_asstrf_l3 boss2_asstrf_l4 boss2_asstrf_l5 boss2_asstrf_l6 boss2_asstrf_l7 boss2_asstrf_l8 boss2_asstrf_l9 boss2_asstrf_l10
$frame boss2_asstrf_l11 boss2_asstrf_l12 boss2_asstrf_l13 boss2_asstrf_l14 boss2_asstrf_l15 boss2_asstrf_l16 boss2_asstrf_l17 boss2_asstrf_l18 boss2_asstrf_l19 boss2_asstrf_l20
$frame boss2_asstrf_l21 boss2_asstrf_l22 boss2_asstrf_l23 boss2_asstrf_l24 boss2_asstrf_l25 boss2_asstrf_l26 boss2_asstrf_l27 boss2_asstrf_l28 boss2_asstrf_l29 boss2_asstrf_l30

$frame boss2_asstrf_r1 boss2_asstrf_r2 boss2_asstrf_r3 boss2_asstrf_r4 boss2_asstrf_r5 boss2_asstrf_r6 boss2_asstrf_r7 boss2_asstrf_r8 boss2_asstrf_r9 boss2_asstrf_r10
$frame boss2_asstrf_r11 boss2_asstrf_r12 boss2_asstrf_r13 boss2_asstrf_r14 boss2_asstrf_r15 boss2_asstrf_r16 boss2_asstrf_r17 boss2_asstrf_r18 boss2_asstrf_r19 boss2_asstrf_r20
$frame boss2_asstrf_r21 boss2_asstrf_r22 boss2_asstrf_r23 boss2_asstrf_r24 boss2_asstrf_r25 boss2_asstrf_r26 boss2_asstrf_r27 boss2_asstrf_r28 boss2_asstrf_r29 boss2_asstrf_r30

$frame boss2_fstrf_l1 boss2_fstrf_l2 boss2_fstrf_l3 boss2_fstrf_l4 boss2_fstrf_l5 boss2_fstrf_l6 boss2_fstrf_l7 boss2_fstrf_l8 boss2_fstrf_l9 boss2_fstrf_l10
$frame boss2_fstrf_l11 boss2_fstrf_l12 boss2_fstrf_l13 boss2_fstrf_l14 boss2_fstrf_l15

$frame boss2_fstrf_r1 boss2_fstrf_r2 boss2_fstrf_r3 boss2_fstrf_r4 boss2_fstrf_r5 boss2_fstrf_r6 boss2_fstrf_r7 boss2_fstrf_r8 boss2_fstrf_r9 boss2_fstrf_r10
$frame boss2_fstrf_r11 boss2_fstrf_r12 boss2_fstrf_r13 boss2_fstrf_r14 boss2_fstrf_r15

$frame boss2_afstrf_l1 boss2_afstrf_l2 boss2_afstrf_l3 boss2_afstrf_l4 boss2_afstrf_l5 boss2_afstrf_l6 boss2_afstrf_l7 boss2_afstrf_l8 boss2_afstrf_l9 boss2_afstrf_l10
$frame boss2_afstrf_l11 boss2_afstrf_l12 boss2_afstrf_l13 boss2_afstrf_l14 boss2_afstrf_l15

$frame boss2_afstrf_r1 boss2_afstrf_r2 boss2_afstrf_r3 boss2_afstrf_r4 boss2_afstrf_r5 boss2_afstrf_r6 boss2_afstrf_r7 boss2_afstrf_r8 boss2_afstrf_r9 boss2_afstrf_r10
$frame boss2_afstrf_r11 boss2_afstrf_r12 boss2_afstrf_r13 boss2_afstrf_r14 boss2_afstrf_r15

$frame boss2_teleout1 boss2_teleout2 boss2_teleout3 boss2_teleout4 boss2_teleout5 boss2_teleout6 boss2_teleout7 boss2_teleout8 boss2_teleout9 boss2_teleout10

$frame boss2_telein1 boss2_telein2 boss2_telein3 boss2_telein4 boss2_telein5 boss2_telein6 boss2_telein7 boss2_telein8 boss2_telein9 boss2_telein10
$frame boss2_telein11 boss2_telein12 boss2_telein13 boss2_telein14 boss2_telein15

$frame boss2_ateleout1 boss2_ateleout2 boss2_ateleout3 boss2_ateleout4 boss2_ateleout5 boss2_ateleout6 boss2_ateleout7 boss2_ateleout8 boss2_ateleout9 boss2_ateleout10

$frame boss2_atelein1 boss2_atelein2 boss2_atelein3 boss2_atelein4 boss2_atelein5 boss2_atelein6 boss2_atelein7 boss2_atelein8 boss2_atelein9 boss2_atelein10

$frame boss2_attacka1 boss2_attacka2 boss2_attacka3 boss2_attacka4 boss2_attacka5 boss2_attacka6 boss2_attacka7 boss2_attacka8 boss2_attacka9 boss2_attacka10
$frame boss2_attacka11 boss2_attacka12 boss2_attacka13 boss2_attacka14 boss2_attacka15 boss2_attacka16 boss2_attacka17 boss2_attacka18 boss2_attacka19 boss2_attacka20
$frame boss2_attacka21 boss2_attacka22

$frame boss2_aattacka1 boss2_aattacka2 boss2_aattacka3 boss2_aattacka4 boss2_aattacka5 boss2_aattacka6 boss2_aattacka7 boss2_aattacka8 boss2_aattacka9 boss2_aattacka10
$frame boss2_aattacka11 boss2_aattacka12 boss2_aattacka13 boss2_aattacka14 boss2_aattacka15 boss2_aattacka16 boss2_aattacka17 boss2_aattacka18 boss2_aattacka19 boss2_aattacka20
$frame boss2_aattacka21 boss2_aattacka22

$frame boss2_attackb1 boss2_attackb2 boss2_attackb3 boss2_attackb4 boss2_attackb5 boss2_attackb6 boss2_attackb7 boss2_attackb8 boss2_attackb9 boss2_attackb10
$frame boss2_attackb11 boss2_attackb12 boss2_attackb13 boss2_attackb14 boss2_attackb15 boss2_attackb16 boss2_attackb17 boss2_attackb18 boss2_attackb19 boss2_attackb20
$frame boss2_attackb21 boss2_attackb22

$frame boss2_aattackb1 boss2_aattackb2 boss2_aattackb3 boss2_aattackb4 boss2_aattackb5 boss2_aattackb6 boss2_aattackb7 boss2_aattackb8 boss2_aattackb9 boss2_aattackb10
$frame boss2_aattackb11 boss2_aattackb12 boss2_aattackb13 boss2_aattackb14 boss2_aattackb15 boss2_aattackb16 boss2_aattackb17 boss2_aattackb18 boss2_aattackb19 boss2_aattackb20
$frame boss2_aattackb21 boss2_aattackb22

$frame boss2_attackc1 boss2_attackc2 boss2_attackc3 boss2_attackc4 boss2_attackc5 boss2_attackc6 boss2_attackc7 boss2_attackc8 boss2_attackc9 boss2_attackc10
$frame boss2_attackc11 boss2_attackc12 boss2_attackc13 boss2_attackc14 boss2_attackc15 boss2_attackc16

$frame boss2_aattackc1 boss2_aattackc2 boss2_aattackc3 boss2_aattackc4 boss2_aattackc5 boss2_aattackc6 boss2_aattackc7 boss2_aattackc8 boss2_aattackc9 boss2_aattackc10
$frame boss2_aattackc11 boss2_aattackc12 boss2_aattackc13 boss2_aattackc14 boss2_aattackc15 boss2_aattackc16

$frame boss2_attackd_l1 boss2_attackd_l2 boss2_attackd_l3 boss2_attackd_l4 boss2_attackd_l5 boss2_attackd_l6 boss2_attackd_l7 boss2_attackd_l8 boss2_attackd_l9 boss2_attackd_l10
$frame boss2_attackd_l11 boss2_attackd_l12 boss2_attackd_l13 boss2_attackd_l14 boss2_attackd_l15 boss2_attackd_l16 boss2_attackd_l17 boss2_attackd_l18 boss2_attackd_l19 boss2_attackd_l20
$frame boss2_attackd_l21 boss2_attackd_l22 boss2_attackd_l23 boss2_attackd_l24 boss2_attackd_l25 boss2_attackd_l26 boss2_attackd_l27 boss2_attackd_l28 boss2_attackd_l29 boss2_attackd_l30

$frame boss2_attackd_r1 boss2_attackd_r2 boss2_attackd_r3 boss2_attackd_r4 boss2_attackd_r5 boss2_attackd_r6 boss2_attackd_r7 boss2_attackd_r8 boss2_attackd_r9 boss2_attackd_r10
$frame boss2_attackd_r11 boss2_attackd_r12 boss2_attackd_r13 boss2_attackd_r14 boss2_attackd_r15 boss2_attackd_r16 boss2_attackd_r17 boss2_attackd_r18 boss2_attackd_r19 boss2_attackd_r20
$frame boss2_attackd_r21 boss2_attackd_r22 boss2_attackd_r23 boss2_attackd_r24 boss2_attackd_r25 boss2_attackd_r26 boss2_attackd_r27 boss2_attackd_r28 boss2_attackd_r29 boss2_attackd_r30

$frame boss2_aattackd_l1 boss2_aattackd_l2 boss2_aattackd_l3 boss2_aattackd_l4 boss2_aattackd_l5 boss2_aattackd_l6 boss2_aattackd_l7 boss2_aattackd_l8 boss2_aattackd_l9 boss2_aattackd_l10
$frame boss2_aattackd_l11 boss2_aattackd_l12 boss2_aattackd_l13 boss2_aattackd_l14 boss2_aattackd_l15 boss2_aattackd_l16 boss2_aattackd_l17 boss2_aattackd_l18 boss2_aattackd_l19 boss2_aattackd_l20
$frame boss2_aattackd_l21 boss2_aattackd_l22 boss2_aattackd_l23 boss2_aattackd_l24 boss2_aattackd_l25 boss2_aattackd_l26 boss2_aattackd_l27 boss2_aattackd_l28 boss2_aattackd_l29 boss2_aattackd_l30

$frame boss2_aattackd_r1 boss2_aattackd_r2 boss2_aattackd_r3 boss2_aattackd_r4 boss2_aattackd_r5 boss2_aattackd_r6 boss2_aattackd_r7 boss2_aattackd_r8 boss2_aattackd_r9 boss2_aattackd_r10
$frame boss2_aattackd_r11 boss2_aattackd_r12 boss2_aattackd_r13 boss2_aattackd_r14 boss2_aattackd_r15 boss2_aattackd_r16 boss2_aattackd_r17 boss2_aattackd_r18 boss2_aattackd_r19 boss2_aattackd_r20
$frame boss2_aattackd_r21 boss2_aattackd_r22 boss2_aattackd_r23 boss2_aattackd_r24 boss2_aattackd_r25 boss2_aattackd_r26 boss2_aattackd_r27 boss2_aattackd_r28 boss2_aattackd_r29 boss2_aattackd_r30

$frame boss2_staggera1 boss2_staggera2 boss2_staggera3 boss2_staggera4 boss2_staggera5 boss2_staggera6 boss2_staggera7 boss2_staggera8 boss2_staggera9 boss2_staggera10
$frame boss2_staggera11 boss2_staggera12 boss2_staggera13 boss2_staggera14 boss2_staggera15 boss2_staggera16 boss2_staggera17 boss2_staggera18 boss2_staggera19 boss2_staggera20
$frame boss2_staggera21 boss2_staggera22 boss2_staggera23 boss2_staggera24 boss2_staggera25 boss2_staggera26 boss2_staggera27 boss2_staggera28 boss2_staggera29 boss2_staggera30

$frame boss2_destroy1 boss2_destroy2 boss2_destroy3 boss2_destroy4 boss2_destroy5 boss2_destroy6 boss2_destroy7 boss2_destroy8 boss2_destroy9 boss2_destroy10
$frame boss2_destroy11 boss2_destroy12 boss2_destroy13 boss2_destroy14 boss2_destroy15 boss2_destroy16 boss2_destroy17 boss2_destroy18 boss2_destroy19 boss2_destroy20
$frame boss2_destroy21 boss2_destroy22 boss2_destroy23 boss2_destroy24 boss2_destroy25 boss2_destroy26 boss2_destroy27 boss2_destroy28 boss2_destroy29 boss2_destroy30
$frame boss2_destroy31 boss2_destroy32 boss2_destroy33 boss2_destroy34 boss2_destroy35 boss2_destroy36 boss2_destroy37 boss2_destroy38 boss2_destroy39 boss2_destroy40
$frame boss2_destroy41 boss2_destroy42 boss2_destroy43 boss2_destroy44 boss2_destroy45 boss2_destroy46 boss2_destroy47 boss2_destroy48 boss2_destroy49 boss2_destroy50
$frame boss2_destroy51 boss2_destroy52 boss2_destroy53 boss2_destroy54 boss2_destroy55 boss2_destroy56 boss2_destroy57 boss2_destroy58 boss2_destroy59 boss2_destroy60
$frame boss2_destroy61 boss2_destroy62 boss2_destroy63 boss2_destroy64 boss2_destroy65 boss2_destroy66 boss2_destroy67 boss2_destroy68 boss2_destroy69 boss2_destroy70
$frame boss2_destroy71 boss2_destroy72 boss2_destroy73 boss2_destroy74 boss2_destroy75 boss2_destroy76 boss2_destroy77 boss2_destroy78 boss2_destroy79 boss2_destroy80
$frame boss2_destroy81 boss2_destroy82 boss2_destroy83 boss2_destroy84 boss2_destroy85 boss2_destroy86 boss2_destroy87 boss2_destroy88 boss2_destroy89 boss2_destroy90
$frame boss2_destroy91 boss2_destroy92 boss2_destroy93 boss2_destroy94 boss2_destroy95 boss2_destroy96 boss2_destroy97 boss2_destroy98 boss2_destroy99 boss2_destroy100

$frame boss2_staggerb1 boss2_staggerb2 boss2_staggerb3 boss2_staggerb4 boss2_staggerb5 boss2_staggerb6 boss2_staggerb7 boss2_staggerb8 boss2_staggerb9 boss2_staggerb10
$frame boss2_staggerb11 boss2_staggerb12 boss2_staggerb13 boss2_staggerb14 boss2_staggerb15 boss2_staggerb16 boss2_staggerb17 boss2_staggerb18 boss2_staggerb19 boss2_staggerb20
$frame boss2_staggerb21 boss2_staggerb22 boss2_staggerb23 boss2_staggerb24 boss2_staggerb25 boss2_staggerb26 boss2_staggerb27 boss2_staggerb28 boss2_staggerb29 boss2_staggerb30

$frame boss2_death1 boss2_death2 boss2_death3 boss2_death4 boss2_death5 boss2_death6 boss2_death7 boss2_death8 boss2_death9 boss2_death10
$frame boss2_death11 boss2_death12 boss2_death13 boss2_death14 boss2_death15 boss2_death16 boss2_death17 boss2_death18 boss2_death19 boss2_death20
$frame boss2_death21 boss2_death22 boss2_death23 boss2_death24 boss2_death25 boss2_death26 boss2_death27 boss2_death28 boss2_death29 boss2_death30
$frame boss2_death31 boss2_death32 boss2_death33 boss2_death34 boss2_death35 boss2_death36 boss2_death37 boss2_death38 boss2_death39 boss2_death40
$frame boss2_death41 boss2_death42 boss2_death43 boss2_death44 boss2_death45 boss2_death46 boss2_death47 boss2_death48 boss2_death49 boss2_death50

#if 1
#include "monster_boss3.qc"
#include "brushtrigger.h"
entity boss_center;
entity boss2_ghost_spawn(entity puppet);
#pragma warning disable F317
#pragma warning disable Q106
#define AGG(fr) (fr + anim_offset)

#define BOSS2_ATTACKS 	\
	PROJECTILE_DIRECT, 	\
	PROJECTILE_HOMING, 	\
	HITSCAN_DIRECT, 	\
	HITSCAN_SPAM, 		\
	HITSCAN_CHAIN

/* #region Reki's new stuff */
static enumflags B2ATTACK_FL:float {
	NONE = 0,
	BOSS2_ATTACKS,
	MAX
};
static enum B2ATTACK_E:float {
	BOSS2_ATTACKS,
	MAX
};
static B2ATTACK_FL boss2_validattacks;
nosave .float hoverloop;

class boss2_c {

	float stage; // stage index

	// Reki (September 20 2023): animation lock
	// set an animation by calling this.animation_start(frame_start, frame_end, frame_func);
	// these are stage agnostic, and will return to normal stage logic after being completed
	float animlock_start;
	float animlock_end;
	float animlock_timestop;
	var virtual float() animlock_think; // returns TRUE if it handled the animation logic
	//

	nonvirtual void() boss2_c;
	nonvirtual void(float, float, float()) animation_start;
	nonvirtual void(float) trigger_stage;
	nonvirtual void() activate;
	nonvirtual void() destructor;
	nonvirtual void(float) turn_to_player;

	float boss_health; // used with s2
	float health_limiter;
	float health_gems;
	entity shield_visual;
	entity puppet;
	entity beam_controller;
	vector puppet_offset;
	vector puppet_vel;
	nonvirtual void() puppet_movement;
	nonvirtual void(vector, vector) appear_at_position;

	// attacks
	var float attack_score[B2ATTACK_E::MAX];
	var virtual float(float) attack_evaluate[B2ATTACK_E::MAX];
	var virtual void() attack_func[B2ATTACK_E::MAX];
	nonvirtual void() run_attacks;
	nonvirtual void() manage_attacks; // managing the attack priorities

	// introduction
	nonvirtual void() stage0;
	nonvirtual void() stage0_frame; // this plays always, even if an animlock is happening so be careful
	nonvirtual float() anim_wakeup;
	nonvirtual float() anim_rude;
	nonvirtual void(entity, float) pain_stage0;
	//

	// crystal levers
	nonvirtual void() stage1;
	nonvirtual void() stage1_frame; // this plays always, even if an animlock is happening so be careful
	nonvirtual float() anim_teleportin;
	nonvirtual float() anim_teleportout;
	//nonvirtual float() anim_scowl;
	nonvirtual float() anim_transitionstage2;
	nonvirtual void(entity, float) pain_stage1;
	entity node_current;
	float levers_remaining;
	float force_attack;
	float shields_up;
	//
	
	// arena
	nonvirtual void() stage2;
	nonvirtual void(entity, float) pain_stage2;
	nonvirtual void() stage2_frame; // this plays always, even if an animlock is happening so be careful
	nonvirtual float() anim_appearwait;
	nonvirtual float() anim_destruction1;
	nonvirtual float() anim_destruction2;
	nonvirtual float() anim_death;
	nonvirtual float() anim_gemshattered;
	float is_aggressive;
	float travel_direction;
	float travel_speed;
	float travel_oncircle;
	float travel_time;
	float travel_attack;
	float travel_pause;
	vector travel_position;
	entity node_next;
	//

	nonvirtual void() mainloop;

	// attacks
	nonvirtual float() anim_projectile_direct;
	nonvirtual float() anim_projectile_homing;
	nonvirtual float() anim_hitscan_direct;
	nonvirtual float() anim_hitscan_spam;
	nonvirtual float() anim_hitscan_chain;

	nonvirtual float(float) evaluate_projectile_direct;
	nonvirtual float(float) evaluate_projectile_homing;
	nonvirtual float(float) evaluate_hitscan_direct;
	nonvirtual float(float) evaluate_hitscan_spam;
	nonvirtual float(float) evaluate_hitscan_chain;

	nonvirtual void() attack_projectile_direct;
	nonvirtual void() attack_projectile_homing;
	nonvirtual void() attack_hitscan_direct;
	nonvirtual void() attack_hitscan_spam;
	nonvirtual void() attack_hitscan_chain;
};

/* #region attacks */
void trigger_boss2_weaponmode_touch(void)
{
	if !(other.flags & FL_CLIENT)
		return;

	boss2_validattacks = (B2ATTACK_FL)self.spawnflags;
};


void spawnfunc_trigger_boss2_weaponmode(void)
{
	if (!self.model)
	{
		remove(self);
		return;
	}

	setmodel(self, self.model);
	self.touch = trigger_boss2_weaponmode_touch;
	init_precise_trigger_collision();
}

void boss2_handeffect_think(void)
{
	frametime = 0.025;
	self.alpha -= 4 * frametime;
	if (self.alpha <= 0)
	{
		remove(self);
		return;
	}

	self.nextthink = time + frametime;
	self.think = boss2_handeffect_think;
}

entity boss2_spawnhandeffect(entity e = (entity)0, string tagname = "", float doattach = 1) // Reki (October 5 2023): helper func for hand sprite effect kristus added
{
	entity effect = spawn();
	setmodel(effect, "models/enemies/boss2/hand_sprite.md3");
	if (tagname && e)
	{
		if (doattach)
			setattachment(effect, e, tagname);
		else
			setorigin(effect, gettaginfo(e, gettagindex(e, tagname)));
	}
	else if (e)
	{
		setorigin(effect, (e.absmin + e.absmax) / 2);
	}
	effect.alpha = 1;
	effect.nextthink = time + 0.025;
	effect.think = boss2_handeffect_think;
	return effect;
}

// proj direct
void boss2_projectile_touch(void)
{ 
	if (other == self.owner)
		return;
	if(other.solid == SOLID_TRIGGER)
		return;
	if(other.wrathflags & FL_PROJECTILE)
		return;
	

	self.solid = SOLID_NOT;
	if (pointcontents(self.origin) == CONTENT_SKY)
	{
		remove(self);
		return;
	}
	//makevectors (self.angles);
	//te_customflash (self.origin,128,0.55,'0.75 0.2 0.75');
	float kb_mult = (self.damagerate / boss2_projdamage);
	self.traileffectnum = particleeffectnum("null");
	entity ignoreentity;
	if (other.health)
	{
		ignoreentity = other;
		T_Damage(other, self, self.owner, self.damagerate);
	}
	else
		ignoreentity = world;

	float radius = boss2_projradius * ((kb_mult + 1) / 2);
	
	T_SplashDamage(self,self.owner, self.damagerate, ignoreentity, radius);

	for(entity lst = findradius(self.origin, radius + 32); lst; lst = lst.chain)
	{
		if (lst.takedamage == DAMAGE_NO)
			continue;

		if !(lst.flags & FL_CLIENT)
			continue;

		vector center_point = ((lst.absmin + lst.absmax)/2);
		float dmg_mult = 1 - (vlen(self.origin - center_point) / radius);
		if (dmg_mult <= 0) // ent was out of range
			continue;

		// apply knockback
		float old_vel = vlen(lst.velocity);
		lst.flags &= ~FL_ONGROUND;
		lst.velocity[2] += 250 * dmg_mult * kb_mult;
		lst.velocity += normalize(center_point - self.origin) * 300 * dmg_mult * kb_mult;
		if (vlen(lst.velocity) > 500)
			lst.velocity = normalize(lst.velocity) * max(500, old_vel);
		//
	}

	spawn_shaker(self, 12, 0.5, 256);
	sound(self, CHAN_BODY, "misc/null.wav", 0, 0);
	sound7(self, CHAN_AUTO, sprintf("enemies/brute/proj_impact%.0f.ogg", ceil(random(3))), 1, 0.25, random(95,105), 0);
	self.touch = SUB_Null;
	self.movetype = 0; 


	self.velocity = '0 0 0';
	self.touch = SUB_Null;
	self.solid = SOLID_NOT;
	makevectors(self.angles);
	self.angles = '0 0 0';
	self.frame = 0;
	self.scale = 2;
	pointparticles(particleeffectnum("wretch_explo"), self.origin, '0 0 0', 3);
	setmodel(self, "models/projectiles/proj_wretch_explo.md3");
	self.skin = 1;
	self.alpha = 1;
	self.think = cannon_proj_touch_fade;
	self.nextthink  =  time + 0.05;
};

entity boss2_fire_projectile(entity shooter, vector from, vector to)
{
	entity missile;
	missile = spawn ();
    missile.owner = shooter;
    missile.movetype = MOVETYPE_BOUNCE;
    missile.solid = SOLID_TRIGGER;
	missile.wrathflags |= FL_PROJECTILE;
	missile.velocity = normalize(to - from) + [random(-0.05, 0.05), random(-0.05, 0.05), 0];
	missile.velocity = missile.velocity * boss2_projspeed;
	missile.velocity_z += random(32,192);
	missile.damagerate = boss2_projdamage;
	missile.gravity = 0.25;
	missile.enemy = single_player;
	missile.traileffectnum = particleeffectnum("proj_wretch_trail");
    missile.angles = vectoangles(missile.velocity);
    missile.touch = boss2_projectile_touch;
    missile.lifetime = time + 15;
	missile.pflags = PFLAGS_FULLDYNAMIC | PFLAGS_LODFADE;
	missile.color = '0.75 0.2 0.7';
	missile.style = 3;
	missile.light_lev = 192;
	missile.scale = 4;

	setmodel(missile, "models/projectiles/proj_wretch.md3");
	missile.colormod = '1 0.3 0.55';

    setsize(missile, '-5 -5 -5', '5 5 5');
	te_customflash(from, 92, 0.55, '0.75 0.6 0.2');
    setorigin(missile, from);

	soundwrath(missile, CHAN_ITEM, "enemies/boss2/fire_loop.ogg", 1, 1, 0, SOUNDFLAG_FORCELOOP, 0.2);

	missile.think = brutegrenadethink;
	missile.nextthink = time + 0.1;

	return missile;
}

float boss2_c::anim_projectile_direct(void)
{
	// Reki (October 5 2023): special offset for aggressive animation
	float anim_offset = 0;
	if (this.is_aggressive)
		anim_offset = $boss2_aattacka1 - $boss2_attacka1;
	//

	static float scowl_mode;
	scowl_mode = FALSE;
	//if (this.frame >= $boss2_scowl1 && this.frame <= $boss2_scowl45)
	//	scowl_mode = TRUE;

	string firepos = __NULL__;
	float leading = 0;

	if (this.frame == AGG($boss2_attacka10))
	{
		firepos = "tag_h_t_right";
		leading = 0.4;
	}
	else if (this.frame == AGG($boss2_attacka13))
	{
		firepos = "tag_h_m_left";
		leading = 0.8;
	}
	else if (this.frame == AGG($boss2_attacka16))
	{
		firepos = "tag_h_b_right";
		leading = 1;
	}

	if (scowl_mode && this.frame == $boss2_scowl24)
	{
		this.anim_teleportout();
		return FALSE;
	}
	
	if (firepos == __NULL__)
		return FALSE;

	if (skill <= 0) // easy
		leading *= 0.3;
	else if (skill == 1) // medium
		leading *= 0.6;
	else if (skill == 2) // hard
		leading *= 1;
	else if (skill >= 3) // outlander
		leading *= random(0.8, 1); // unpredictable leading

	float tag = gettagindex(this.puppet, firepos);
	vector from = gettaginfo(this.puppet, tag);
	vector to = [single_player.origin[0], single_player.origin[1], single_player.absmin[2] + random(6, 12)];
	float delta = vlen(to - from) / boss2_projspeed;
	to += single_player.velocity * delta * leading;

	entity missile = boss2_fire_projectile(this, from, to);
	if (this.stage == 1)
		missile.damagerate *= 0.8;

	soundwrath(this, CHAN_AUTO, sprintf("enemies/boss2/throw_fire%.0f.ogg", floor(random(5)) + 1), 1, 0.25, 0, 0, 0.3);

	return FALSE;
}

float boss2_c::evaluate_projectile_direct(float score)
{
	score *= 0.95; // prefer hitscan attacks

	if (this.stage == 1 && force_attack == 2)
	{
		force_attack--;
		return 9999;
	}

	traceline(this.origin, this.enemy.origin, MOVE_NORMAL, this);
	if !(trace_ent.flags & FL_CLIENT) // no clear shot, no point firing into the pillar
		score *= 0.2;

	return score;
}
void boss2_c::attack_projectile_direct(void)
{
	dprint(__func__, "\n");
	attack_score[B2ATTACK_E::PROJECTILE_DIRECT] -= 7;
	this.attack_finished = time + 3;

	soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/throw_vocal.ogg", 1, 0.125, 0, 0, 0.5);

	if (this.is_aggressive)
		this.animation_start($boss2_aattacka1, $boss2_aattacka22, anim_projectile_direct);
	else
		this.animation_start($boss2_attacka1, $boss2_attacka22, anim_projectile_direct);
}

// proj homing
void boss2_projectile_homingredirect(void)
{
	for(float i = 0; i < 5; i++)
	{
		entity missile = boss2_fire_projectile(self, self.origin, single_player.origin);
		setmodel(missile, "models/projectiles/proj_wretch.md3");
		setsize(missile, '-1 -1 -1', '1 1 1');
		missile.colormod = '1 0.5 0.9';
		missile.scale = 1.5;
		missile.velocity += [random(-64, 64), random(-64, 64), random(-64, 32)];
		missile.damagerate *= 0.4;
		missile.gravity = 0.2;
	}

	soundwrath(self, CHAN_BODY, "enemies/boss2/homing_split.ogg", 1, 0.125, 0, 0, 0.15);
	remove(self);
	
	/*
	self.movetype = MOVETYPE_BOUNCE;
	self.velocity = normalize(single_player.origin - self.origin) * boss2_projspeed;
	self.angles = vectoangles(self.velocity);

	self.think = brutegrenadethink;
	self.nextthink = time + 0.02;
	*/
}

float boss2_c::anim_projectile_homing(void)
{
	// Reki (October 5 2023): special offset for aggressive animation
	float anim_offset = 0;
	if (this.is_aggressive)
		anim_offset = $boss2_aattackb1 - $boss2_attackb1;
	//

	if (this.frame != AGG($boss2_attackb12))
		return FALSE;

	boss2_ghost_spawn(this.puppet); // spawn ghost shell animation

	// fire missle
	float tag = gettagindex(this.puppet, "tag_beam");
	vector from = gettaginfo(this.puppet, tag);
	vector to = [single_player.origin[0], single_player.origin[1], single_player.absmin[2] + random(6, 12)];
	entity missile = boss2_fire_projectile(this, from, to);

	// find valid firing path to player
	vector pos;
	vector diff = boss_center.origin - this.puppet.origin; diff[2] = 0; // difference with no z axis
	makevectors(vectoangles(diff));
	
	for(float i = 0; i < 16; i++) // try some random firing positions
	{
		if (this.stage == 1) // stage 1 we want to go forward more than up
		{
			pos = (this.puppet.origin + single_player.origin) / 2;
			pos += v_right * random(32, 64) * ((round(random()) * 2) - 1);
			pos[2] += random(256, 384); 
		}
		else
		{
			pos = this.puppet.origin + (v_forward * random(384, 512));
			pos += v_right * random(128, 496) * ((round(random()) * 2) - 1);
			pos[2] += random(440, 768); // we want UP on the z axis, launching into the ground would do us no good
		}

		traceline(from, pos, MOVE_NORMAL, this);
		if (trace_fraction < 1)
			pos = trace_endpos + (trace_plane_normal * 64);

		traceline(pos, to, MOVE_NOMONSTERS, this);
		if (trace_fraction < 1)
			continue;
		break;
	}

	// readjust missile's course
	float spd = 440;
	missile.movetype = MOVETYPE_FLY;
	missile.velocity = normalize(pos - missile.origin) * spd;
	missile.angles = vectoangles(missile.velocity);

	missile.think = boss2_projectile_homingredirect;
	missile.nextthink = time + (vlen(pos - missile.origin) / spd);

	soundwrath(this, CHAN_ITEM, "enemies/boss2/homing_fire.ogg", 1, 0.125, 0, 0, 0.15);
	soundwrath(missile, CHAN_BODY, "enemies/boss2/homing_loop.ogg", 1, 0.25, 0, SOUNDFLAG_FORCELOOP, 0);


	return FALSE;
}

float boss2_c::evaluate_projectile_homing(__inout float score)
{
	if (score < 12) // we don't want to spam this
	{
		score = 0;
		return score;
	}

	traceline(this.origin, this.enemy.origin, MOVE_NORMAL, this);
	if !(trace_ent.flags & FL_CLIENT) // a pillar is blocking, lets try to shoot around it
		score *= 1.5;

	return score;
}
void boss2_c::attack_projectile_homing(void)
{
	dprint(__func__, "\n");
	attack_score[B2ATTACK_E::PROJECTILE_HOMING] -= 20;
	this.attack_finished = time + 4;

	soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/homing_vocal.ogg", 1, 0.125, 0, 0, 0.5);

	if (this.is_aggressive)
		this.animation_start($boss2_aattackb1, $boss2_aattackb22, anim_projectile_homing);
	else
		this.animation_start($boss2_attackb1, $boss2_attackb22, anim_projectile_homing);
}

// hitscan direct
vector boss2_beam_aimpos;
void boss2_hitscandamage(vector p1, vector p2, entity from, float damage)
{

	local entity		e1, e2;
	local vector		f;
	f = p2 - p1;
	normalize (f);
	f_x = 0 - f_y;
	f_y = f_x;
	f_z = 0;
	f = f*16;
	e1 = e2 = world;
	traceline (p1, p2, FALSE, from);

	float r2 = random();

	if(r2 < 0.5)
	{	

		entity muzzle = spawn();
		setmodel (muzzle,"models/projectiles/proj_wretch.md3");
		setorigin(muzzle,trace_endpos);
		muzzle.scale = 0.3;
		muzzle.colormod = '0.9 0 0.75';
		muzzle.think = SUB_Remove;
		muzzle.nextthink = time + 0.75;

		sound7 (from, CHAN_AUTO, "weapons/crystal/crystalise.ogg", 1, 0.25,random(150,200),0);
		sound7 (from, CHAN_AUTO, "fx/tele4.ogg", 1, 0.5,random(150,200),0);
		if(r2 < 0.25)
		{
		te_customflash ( trace_endpos,92,1,'0.9 0 0.75');
		spawn_relevelation_particles(trace_endpos,7,'0.8 0.25 0.75',1);
		sound7 (from, CHAN_AUTO, "fx/tele3.ogg", 1, 0.5,random(150,200),0);
		}
		if(r2 < 0.1)
		sound7 (from, CHAN_AUTO, "fx/tele2.ogg", 1, 0.5,random(150,200),0);

	}
	pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
	if (trace_ent.takedamage)
	{
		vector dorg = p2; // + trace_endpos) * 0.5;
		pointparticles(particleeffectnum("crystal_impact3"), dorg, '0 0 0', 1);
		SpawnBlood(dorg, '0 0 0', 10, 1, 0);
		pointparticles(particleeffectnum("crystal_impact1"), dorg, '0 0 0', 1);
		T_Damage (trace_ent, from, from, (trace_ent.wrathflags & FL_CRYSTAL) ? damage * 0.1 : damage);
	}
	e1 = trace_ent;
	traceline (p1 + f, p2 + f, FALSE, from);
	if (trace_ent != e1 && trace_ent.takedamage)
	{
		pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
		T_Damage (trace_ent, from, from, (trace_ent.wrathflags & FL_CRYSTAL) ? damage * 0.1 : damage);
	}
	e2 = trace_ent;
	traceline (p1 - f, p2 - f, FALSE, from);
	if (trace_ent != e1 && trace_ent != e2 && trace_ent.takedamage)
	{
		pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
		T_Damage (trace_ent, from, from, (trace_ent.wrathflags & FL_CRYSTAL) ? damage * 0.1 : damage);
	}
};

float boss2_c::anim_hitscan_direct(void)
{
	// Reki (October 5 2023): special offset for aggressive animation variations
	float anim_offset = 0;
	if (this.is_aggressive)
		anim_offset = $boss2_aattackc1 - $boss2_attackc1;
	//

	static float hitscandirect_timeout;
	static float hitscandirect_player_lasthit;
	this.beam_controller.attack_finished = 0;
	this.attack_finished = max(this.attack_finished, time + 0.5);

	if (this.frame == AGG($boss2_attackc1))
	{
		hitscandirect_player_lasthit = time + 1.5;

		// timeout is the cutoff, we stop attacking after this no matter what
		if (skill <= 0) // easy
			hitscandirect_timeout = time + 2; // keep the hitscan shots short on easy
		else if (skill == 1 || this.stage < 2) // medium
			hitscandirect_timeout = time + 3;
		else if (skill == 2) // hard
			hitscandirect_timeout = time + 4;
		else if (skill >= 3) // outlander
			hitscandirect_timeout = time + 100; // the pain train NEVER stops
	}

	if (this.frame < AGG($boss2_attackc6))
		return FALSE;
	
	if (this.frame == AGG($boss2_attackc14))
	{
		if (((time - hitscandirect_player_lasthit) < 1) && (time < hitscandirect_timeout))
			this.frame = AGG($boss2_attackc6);
	}

	if (this.frame < AGG($boss2_attackc6) || this.frame >= AGG($boss2_attackc14))
		return FALSE;

	float tag = gettagindex(this.puppet, "tag_beam");
	vector from = gettaginfo(this.puppet, tag);
	vector to = boss2_beam_aimpos;

	traceline(from, to, MOVE_NORMAL, this);
	if (trace_ent.flags & FL_CLIENT)
		hitscandirect_player_lasthit = time;
	
	entity o_self = self; // wtf??? why is this messing up self value
	boss2_hitscandamage(from, to, this, (this.stage == 2) ? (boss2_beamdamage) : (boss2_beamdamage * 0.5));
	self = (boss2_c)o_self;
	this.beam_controller.attack_finished = time + 0.15;

	return FALSE;
}

float boss2_c::evaluate_hitscan_direct(float score)
{
	if (this.stage == 1)
	{
		score *= 0.5; // stage 1, we want this to be rare at best
	}

	if (score < 5) // we don't want to spam this
	{
		score = 0;
		return score;
	}

	if (vlen(this.enemy.origin - this.origin) > 1700) // player is really far away... don't do it!
	{
		score = 0;
		return score;
	}

	traceline(this.origin, this.enemy.origin, MOVE_NORMAL, this);
	if !(trace_ent.flags & FL_CLIENT) // no clear shot, no point firing into the pillar
		score *= 0.3;

	return score;
}
void boss2_c::attack_hitscan_direct(void)
{
	dprint(__func__, "\n");
	if (this.stage == 2)
	{
		attack_score[B2ATTACK_E::HITSCAN_DIRECT] -= 11;
		this.attack_finished = time + 4;
	}
	else
	{
		attack_score[B2ATTACK_E::HITSCAN_DIRECT] -= 20;
		this.attack_finished = time + 9;
	}

	soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/hitscan_vocal.ogg", 1, 0.125, 0, 0, 0.5);

	this.enemy = single_player; // aim for the player!
	if (this.is_aggressive)
		this.animation_start($boss2_aattackc1, $boss2_aattackc16, anim_hitscan_direct);
	else
		this.animation_start($boss2_attackc1, $boss2_attackc16, anim_hitscan_direct);
}

// hitscan spam
float hitscan_spam_wait;
float hitscan_spam_seek;
string hitscan_spam_order[] = {"tag_h_t_right", "tag_h_b_left", "tag_h_m_right", "tag_h_t_left", "tag_h_b_right", "tag_h_m_left"};

float boss2_c::anim_hitscan_spam(void)
{
	// Reki (October 5 2023): special offset for aggressive animation
	float anim_offset = 0;
	if (this.is_aggressive)
		anim_offset = $boss2_aattackd_l1 - $boss2_attackd_l1;
	//

	if ((travel_direction && this.frame >= AGG($boss2_attackd_r28)) || (!travel_direction && this.frame >= AGG($boss2_attackd_l28))) // we're transitioning out!
		return FALSE;

	if (hitscan_spam_seek >= (hitscan_spam_order.length * 9))
	{
		if (travel_direction)
			this.frame = AGG($boss2_attackd_r28);
		else
			this.frame = AGG($boss2_attackd_l28);
		return FALSE;
	}

	if (this.frame == AGG($boss2_attackd_l1)) // we need to transition in
	{
		if (travel_direction)
			this.frame = AGG($boss2_attackd_r2);
		else
			this.frame = AGG($boss2_attackd_l2);
		return TRUE;
	}
	
	this.enemy = boss_center;
	travel_speed = max(600, travel_speed);
	this.frame++;
	if (travel_direction)
	{
		if (this.frame < AGG($boss2_attackd_r3) || this.frame > AGG($boss2_attackd_r27))
			this.frame = AGG($boss2_attackd_r3);
	}
	else
	{
		if (this.frame < AGG($boss2_attackd_l3) || this.frame > AGG($boss2_attackd_l27))
			this.frame = AGG($boss2_attackd_l3);
	}

	//if (time < hitscan_spam_wait)
	//	return TRUE;
	
	string tagname = hitscan_spam_order[hitscan_spam_seek % hitscan_spam_order.length];
	float tag = gettagindex(this.puppet, tagname);
	vector from = gettaginfo(this.puppet, tag);
	vector to;
	vector dir;

	makevectors(this.puppet.angles);
	if (random() < 0.7)
		to = single_player.origin + [random(-128, 128), random(-128, 128), random(-24, 32)];
	else
		to = this.puppet.origin + (v_forward * 1024) + (v_right * random(-128, 128)) + (v_up * random(-256, 0));
	
	dir = normalize(to - from);
	dir[0] *= random(0.95, 1.05);
	dir[1] *= random(0.95, 1.05);
	dir[2] *= random(0.95, 1.00);

	to = from + (dir * 2048);

	entity o_self = self; // wtf??? why is this messing up self value
	boss2_hitscandamage(from, to, this, boss2_beamdamage);
	self = (boss2_c)o_self;
	
	traceline(from, to, MOVE_NORMAL, this);
	to = trace_endpos;

	entity poof = boss2_spawnhandeffect(this.puppet, tagname, 0); // Reki (October 5 2023): Spawn hand poof (lasts short period and fades)
	soundwrath(poof, CHAN_AUTO, sprintf("enemies/boss2/hitscanspam_fire%.0f.ogg", floor(random(5)) + 1), 1, 0.25, 0, 0, 0.3);
	poof.scale = random(1.5, 2);

	WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
	WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
	WriteVectorL(MSG_BROADCAST, from);
	WriteVectorL(MSG_BROADCAST, to);
	WriteByte16(MSG_BROADCAST, 2); // beam scale
	WriteShort(MSG_BROADCAST, 0); // `self` meaning the entity that owns the beam
	WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter

	hitscan_spam_seek++;
	//hitscan_spam_wait = time + 0.08;
	
	return TRUE;
}

float boss2_c::evaluate_hitscan_spam(float score)
{
	if (score < 10)
	{
		score = 0;
		return score;
	}

	traceline(this.origin, this.enemy.origin, MOVE_NORMAL, this);
	if (trace_ent.flags & FL_CLIENT) // if we have a clear shot, why spam?
		score *= 0.9;

	return score;
}

void boss2_c::attack_hitscan_spam(void)
{
	dprint(__func__, "\n");
	attack_score[B2ATTACK_E::HITSCAN_SPAM] -= 10;
	this.attack_finished = time + 6;

	hitscan_spam_seek = 0;
	hitscan_spam_wait = time + 2;
	this.enemy = single_player; // aim for the player!

	soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/hitscanspam_vocal.ogg", 1, 0.125, 0, 0, 0.5);

	if (this.is_aggressive)
		this.animation_start($boss2_aattackd_l1, $boss2_aattackd_l2, anim_hitscan_spam);
	else
		this.animation_start($boss2_attackd_l1, $boss2_attackd_l2, anim_hitscan_spam);
}

// hitscan chain
float boss2_c::anim_hitscan_chain(void)
{
	// Reki (October 5 2023): special offset for aggressive animation
	float anim_offset = 0;
	if (this.is_aggressive)
		anim_offset = $boss2_aattackc1 - $boss2_attackc1;
	//

	static float hitscanchain_player_lasthit;
	static float hitscanchain_player_maxhit;
	this.beam_controller.attack_finished = 0;

	if (this.frame == AGG($boss2_attackc1))
	{
		hitscanchain_player_lasthit = time + 1.5;
		hitscanchain_player_maxhit = time + 5;
	}

	if (this.frame < AGG($boss2_attackc6))
		return FALSE;
	
	if (this.frame == AGG($boss2_attackc14))
	{
		if (((time - hitscanchain_player_lasthit) < 1) && (time < hitscanchain_player_maxhit))
			this.frame = AGG($boss2_attackc6);
	}

	if (this.frame < AGG($boss2_attackc6) || this.frame >= AGG($boss2_attackc14))
		return FALSE;

	this.beam_controller.attack_finished = time + 0.15;

	float tag = gettagindex(this.puppet, "tag_beam");
	vector fromboss = gettaginfo(this.puppet, tag);
	vector from = (this.enemy.absmin + this.enemy.absmax) / 2;
	vector to = single_player.origin;

	boss2_hitscandamage(fromboss, from, this, boss2_beamdamage);

	if (vlen(from - to) > 512)
		return FALSE;

	traceline(fromboss, from, MOVE_NORMAL, this);
	if (trace_ent != this.enemy)
		return FALSE;

	traceline(from, to, MOVE_NORMAL, this.enemy);
	if (trace_ent.flags & FL_CLIENT)
		hitscanchain_player_lasthit = time;
	vector epos = trace_endpos;
	
	entity o_self = self; // wtf??? why is this messing up self value
	boss2_hitscandamage(from, to, this, boss2_beamdamage * 0.25);
	self = (boss2_c)o_self;

	WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
	WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
	WriteVectorL(MSG_BROADCAST, from);
	WriteVectorL(MSG_BROADCAST, epos);
	WriteByte16(MSG_BROADCAST, 2); // beam scale
	WriteShort(MSG_BROADCAST, num_for_edict(this.enemy)); // `self` meaning the entity that owns the beam
	WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter

	return FALSE;
}

static entity boss2_chain_bestent;
float boss2_c::evaluate_hitscan_chain(float score)
{
	score *= 1.2; // chain should be decently high priority base
	traceline(this.origin, this.enemy.origin, MOVE_NORMAL, this);
	if (trace_ent.flags & FL_CLIENT) // if we have a clear shot, less likely to go for the chain
		score *= 0.7;

	entity best_ent = world;
	float best_dist = 99999;
	for(entity lst = findradius(single_player.origin, 512); lst; lst = lst.chain)
	{
		if !(lst.wrathflags & FL_CRYSTAL)
			continue;

		vector pos = (lst.absmin + lst.absmax) / 2;
		float dist = vlen(single_player.origin - pos);

		if (dist > 450)
			continue;

		dist += (vlen(this.origin - pos)) * 0.2;
		
		if (dist > best_dist)
			continue;
		
		traceline(pos, single_player.origin, MOVE_NOMONSTERS, lst);
		if (trace_fraction < 1)
			continue;

		best_dist = dist;
		best_ent = lst;
		break;
	}

	if (!best_ent)
	{
		score = 0;
		return score;
	}

	boss2_chain_bestent = best_ent;
	return score;
}

void boss2_c::attack_hitscan_chain(void)
{
	dprint(__func__, "\n");
	attack_score[B2ATTACK_E::HITSCAN_CHAIN] -= 8;

	this.enemy = boss2_chain_bestent;

	soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/hitscan_vocal.ogg", 1, 0.125, 0, 0, 0.5);

	if (this.is_aggressive)
		this.animation_start($boss2_aattackc1, $boss2_aattackc16, anim_hitscan_chain);
	else
		this.animation_start($boss2_attackc1, $boss2_attackc16, anim_hitscan_chain);
}

/* #endregion */

void boss2_beamcontroller_think(void)
{
	self.think = boss2_beamcontroller_think;
	self.nextthink = time + 0.01388;

	/* #region boss beam aim management */
	// log player position and velocity so we can more humanly track
	static const float BEAM_HISTORY_LENGTH = 12;
	static vector enemy_position_history[BEAM_HISTORY_LENGTH];
	static vector enemy_velocity_history[BEAM_HISTORY_LENGTH];
	static float enemy_time_history[BEAM_HISTORY_LENGTH];
	float velocity_confidence;
	if (skill <= 0) // easy
		velocity_confidence = 0.84;
	else if (skill == 1) // medium
		velocity_confidence = 0.95;
	else if (skill == 2) // hard
		velocity_confidence = 0.95;
	else // outlander
		velocity_confidence = 1;

	for(float i = BEAM_HISTORY_LENGTH - 1; i >= 1; i--) // shuffle all the entries up 1
	{
		enemy_position_history[i] = enemy_position_history[i - 1];
		enemy_velocity_history[i] = enemy_velocity_history[i - 1] * (random(velocity_confidence, 1));
		enemy_time_history[i] = enemy_time_history[i - 1];
	}

	enemy_position_history[0] = single_player.origin;
	enemy_velocity_history[0] = single_player.velocity;
	enemy_time_history[0] = time;
	//

	// calculate where the boss should be aiming (hah, this is just antilag code but in reverse :P)
	float mental_delay;
	if (skill <= 0) // easy
		mental_delay = 0.08;
	else if (skill == 1) // medium
		mental_delay = 0.06;
	else if (skill == 2) // hard
		mental_delay = 0.04;
	else // outlander (you HAVE to hide behind a pillar, otherwise you're screwed)
		mental_delay = 0.021;

	float time_desired = time - mental_delay;
	float i = 1;
	while(enemy_time_history[i] >= time_desired)
	{
		i++;
		if (i >= BEAM_HISTORY_LENGTH) // :( I hope we don't get this far
		{
			i = 0;
			boss2_beam_aimpos = enemy_position_history[0];
			break;
		}
	}

	if (i != 0)
	{
		vector pos;
		float frac = (enemy_time_history[i - 1] - time_desired) / (enemy_time_history[i - 1] - enemy_time_history[i]);
		pos = lerpVector(enemy_position_history[i - 1], enemy_position_history[i], frac) + (lerpVector(enemy_velocity_history[i - 1], enemy_velocity_history[i], frac)) * mental_delay;
		boss2_beam_aimpos = pos;
	}
	
	//
	/* #endregion */

	if !(self.owner.owner.enemy.flags & FL_CLIENT) // if we're not aiming at the player... shoot at center mass of whatever we're aiming for
	{
		entity targ = self.owner.owner.enemy;
		boss2_beam_aimpos = ((targ.absmin) + (targ.absmax)) / 2;
	}

	if (time > self.attack_finished)
		return;

	float tag = gettagindex(self.owner, "tag_beam");
	vector from = gettaginfo(self.owner, tag);
	vector to = boss2_beam_aimpos;
	to = from + (normalize(to - from) * 2048);
	boss2_beam_aimpos = to;

	traceline(from, to, MOVE_NORMAL, self.owner.owner);
	to = trace_endpos;
	
	WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
	WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
	WriteVectorL(MSG_BROADCAST, from);
	WriteVectorL(MSG_BROADCAST, to);
	WriteByte16(MSG_BROADCAST, 2); // beam scale
	WriteShort(MSG_BROADCAST, num_for_edict(self.owner)); // `self` meaning the entity that owns the beam
	WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter
}

float boss2_bonushealth(void) {
	if (skill <= 0)
		return 0;
	else if (skill == 1)
		return 500;
	else if (skill == 2)
		return 1200;
	else
		return 1600;
};

void boss2_c::boss2_c(void) {
	precache_model("models/enemies/boss2/boss2.md3");
	precache_model("models/enemies/boss2/collider.bsp");
	precache_model("models/enemies/boss2/hand_sprite.md3");
	precache_model("models/enemies/boss2/boss2_end.md3");
	precache_model("models/enemies/boss2/boss2_endparticles.md3");

	// sound precaches
	precache_sound("enemies/boss2/crystaloff_powerdown.ogg");
	precache_sound("enemies/boss2/crystaloff_vocal.ogg");
	precache_sound("enemies/boss2/crystaloff_zap1.ogg");
	precache_sound("enemies/boss2/crystaloff_zap2.ogg");
	precache_sound("enemies/boss2/crystaloff_zap3.ogg");
	precache_sound("enemies/boss2/crystaloff_zap4.ogg");
	precache_sound("enemies/boss2/crystaloff_zap5.ogg");
	precache_sound("enemies/boss2/destruction_firebeam1.ogg");
	precache_sound("enemies/boss2/destruction_firebeam2.ogg");
	precache_sound("enemies/boss2/destruction_firebeam3.ogg");
	precache_sound("enemies/boss2/destruction_vocal.ogg");
	precache_sound("enemies/boss2/die1.ogg");
	precache_sound("enemies/boss2/hitscan_vocal.ogg");
	precache_sound("enemies/boss2/hitscanspam_fire1.ogg");
	precache_sound("enemies/boss2/hitscanspam_fire2.ogg");
	precache_sound("enemies/boss2/hitscanspam_fire3.ogg");
	precache_sound("enemies/boss2/hitscanspam_fire4.ogg");
	precache_sound("enemies/boss2/hitscanspam_fire5.ogg");
	precache_sound("enemies/boss2/hitscanspam_vocal.ogg");
	precache_sound("enemies/boss2/homing_fire.ogg");
	precache_sound("enemies/boss2/homing_loop.ogg");
	precache_sound("enemies/boss2/homing_split.ogg");
	precache_sound("enemies/boss2/homing_vocal.ogg");
	precache_sound("enemies/boss2/pain1.ogg");
	precache_sound("enemies/boss2/pain2.ogg");
	precache_sound("enemies/boss2/pain3.ogg");
	precache_sound("enemies/boss2/rude_vocal.ogg");
	precache_sound("enemies/boss2/teleport_in1.ogg");
	precache_sound("enemies/boss2/teleport_in2.ogg");
	precache_sound("enemies/boss2/teleport_in3.ogg");
	precache_sound("enemies/boss2/teleport_out1.ogg");
	precache_sound("enemies/boss2/teleport_out2.ogg");
	precache_sound("enemies/boss2/teleport_out3.ogg");
	precache_sound("enemies/boss2/throw_fire1.ogg");
	precache_sound("enemies/boss2/throw_fire2.ogg");
	precache_sound("enemies/boss2/throw_fire3.ogg");
	precache_sound("enemies/boss2/throw_fire4.ogg");
	precache_sound("enemies/boss2/throw_fire5.ogg");
	precache_sound("enemies/boss2/throw_loop.ogg");
	precache_sound("enemies/boss2/throw_vocal.ogg");
	precache_sound("enemies/boss2/wakeup_vocal.ogg");
	precache_sound("enemies/boss2/hover_loop.ogg");
	//

	setmodel(this, "models/enemies/boss2/collider.bsp");
	setsize(this, '-100 -100 -192', '100 100 224');

	this.classname = "boss_guardian2";
	this.health = 999999;
	this.boss_health = boss2_healtha + boss2_bonushealth();
	this.health_gems = 0x0F;
	this.movetype = MOVETYPE_STEP;
	this.takedamage = DAMAGE_AIM;
	this.solid = SOLID_BSP;
	this.th_die = SUB_Null;
	this.stage = 0;
	this.use = this.activate;
	this.bloodimpact = 9;
	this.effects = EF_NODRAW;
	//this.flags |= FL_MONSTER;

	this.think = this.mainloop;
	this.nextthink = time + 0.2;

	// Reki (September 21 2023): set up puppet model
	this.puppet = spawn();
	setmodel(this.puppet, "models/enemies/boss2/boss2.md3");
	this.puppet.owner = (entity)this;
	this.puppet.movetype = MOVETYPE_STEP;
	this.puppet.flags |= FL_ONGROUND;
	this.puppet.scale = 1.5;

	// Reki (September 20 2023): set up shield model
	this.shield_visual = spawn();
	setmodel(this.shield_visual, this.puppet.model);
	this.shield_visual.skin = 5;
	this.shield_visual.effects = EF_FULLBRIGHT;
	this.shield_visual.movetype = MOVETYPE_STEP;
	this.shield_visual.flags |= FL_ONGROUND;
	this.shield_visual.scale = this.puppet.scale;

	// Reki (September 29 2023): set up beam controller
	this.beam_controller = spawn();
	this.beam_controller.owner = this.puppet;
	this.beam_controller.think = boss2_beamcontroller_think;
	this.beam_controller.nextthink = time + 0.1;

	// Reki (September 24 2023): set up attacks
	/*0*/attack_func[B2ATTACK_E::PROJECTILE_DIRECT] = attack_projectile_direct;
	attack_evaluate[B2ATTACK_E::PROJECTILE_DIRECT] = evaluate_projectile_direct;
	/*1*/attack_func[B2ATTACK_E::PROJECTILE_HOMING] = attack_projectile_homing;
	attack_evaluate[B2ATTACK_E::PROJECTILE_HOMING] = evaluate_projectile_homing;
	/*2*/attack_func[B2ATTACK_E::HITSCAN_DIRECT] = attack_hitscan_direct;
	attack_evaluate[B2ATTACK_E::HITSCAN_DIRECT] = evaluate_hitscan_direct;
	/*3*/attack_func[B2ATTACK_E::HITSCAN_SPAM] = attack_hitscan_spam;
	attack_evaluate[B2ATTACK_E::HITSCAN_SPAM] = evaluate_hitscan_spam;
	/*4*/attack_func[B2ATTACK_E::HITSCAN_CHAIN] = attack_hitscan_chain;
	attack_evaluate[B2ATTACK_E::HITSCAN_CHAIN] = evaluate_hitscan_chain;
}

void spawnfunc_boss_guardian2(void)
{
	spawnfunc_boss2_c();
}

/* #region general routines */
void boss2_ghost_think(void)
{
	self.think = boss2_ghost_think;
	self.nextthink = time + 0.013;
	float delta = (time - self.attack_finished);
	self.attack_finished = time;

	if (self.owner && wasfreed(self.owner))
		self.owner = world;

	if (self.owner)
	{
		self.origin = self.owner.origin;
		self.frame = self.owner.frame;
		self.angles = self.owner.angles;
	}
	
	if (self.spawnflags & 2)
		delta *= 0.25;

	self.alpha -= 5 * delta;
	if !(self.spawnflags & 1)
		self.scale += 3 * delta;

	if (self.alpha <= 0)
	{
		remove(self);
		return;
	}
}

entity boss2_ghost_spawn(entity puppet)
{
	entity ghost = spawn();
	setmodel(ghost, puppet.model);
	setorigin(ghost, puppet.origin);
	ghost.angles = puppet.angles;
	ghost.frame = puppet.frame;
	ghost.skin = 4;
	ghost.owner = puppet;
	ghost.alpha = 1;
	ghost.scale = puppet.scale + 0.1;
	ghost.effects = EF_DOUBLESIDED | EF_ADDITIVE;
	ghost.colormod = '1 0.1 0.8';
	ghost.think = boss2_ghost_think;
	ghost.nextthink = time + 0.1;
	ghost.attack_finished = ghost.nextthink;

	return ghost;
}

void boss2_c::animation_start(float start, float end, float() th)
{
	this.frame = start;
	this.animlock_start = start;
	this.animlock_end = end;
	this.animlock_think = th;
}

void boss2_c::trigger_stage(float st)
{
	if (st < 0 || st > 7) // keep within bounds
		return;

	.string fld = (::targetfieldarray[st]);
	if (!this.fld)
		return;

	for(entity t = find(world, ::targetname, this.fld); t; t = t = find(t, ::targetname, this.fld))
	{
		if (!t.use)
			continue;

		Ent_UseTarget(t);
	}
}

void boss2_c::activate(void)
{
	if (this.stage == 0)
	{
		if (this.animlock_think == this.anim_wakeup)
			return;

		this.animation_start($boss2_wakeup1, $boss2_wakeup60 + 1, this.anim_wakeup);
		soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/wakeup_vocal.ogg", 1, 0.125, 0, 0, 0.5);
		this.levers_remaining = 3;
	}
	else if (this.stage == 1)
	{
		soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/crystaloff_vocal.ogg", 1, 0.125, 0, 0, 0.5);
		this.shields_up = FALSE;
		//this.animation_start($boss2_scowl1, $boss2_scowl45, this.anim_projectile_direct);
		this.animation_start($boss2_scowl1, $boss2_scowl25, this.anim_teleportout);
		//this.force_attack = 1;
		this.attack_finished = time + 2;
		//this.animation_start($boss2_teleout1, $boss2_teleout10, this.anim_teleportout);
		levers_remaining--;
		//if (levers_remaining <= 0)
		//{
		//	
		//}
	}
}

void boss2_c::destructor(void)
{
	if (this.puppet.aiment)
	{
		entity parts = this.puppet.aiment;
		parts.movetype = MOVETYPE_NONE;
		parts.aiment = world;
	}

	sound(this.puppet, CHAN_BODY, "misc/null.wav", 0, ATTN_NORM);
	if (this.shield_visual)
		remove(this.shield_visual);
	if (this.puppet)
		remove(this.puppet);
	if (this.beam_controller)
		remove(this.beam_controller);
	remove(this);
}

void boss2_c::puppet_movement(void)
{
	vector pos_wanted;

	if (this.enemy)
	{	
		vector diff = normalize(this.origin - this.enemy.origin);
		diff[2] *= -2;

		pos_wanted += diff * 112; // stance back a bit from the player
		
		makevectors([-this.enemy.angles[0], this.enemy.angles[1], this.enemy.angles[2]]);
		pos_wanted -= v_forward * 32;
	}

	// friction
	this.puppet_vel *= 0.8;
	if (vlen(this.puppet_vel) > 96)
		this.puppet_vel = normalize(this.puppet_vel) * 96;
	//

	pos_wanted[0] += sin(time * 0.3) * 12;
	pos_wanted[1] += sin((time + 15.13) * 0.35) * 16;
	pos_wanted[2] += sin((time + 1.57) * 0.8) * 24;
	pos_wanted += this.puppet_vel;

	vector diff = (pos_wanted - this.puppet_offset);
	float dist = vlen(diff);
	float spd = 16;
	if (dist > 128)
		spd = 480;
	else if (dist > 96)
		spd = 180;
	else if (dist > 64)
		spd = 112;
	else if (dist > 32)
		spd = 72;
	else if (dist > 24)
		spd = 56;
	else if (dist > 16)
		spd = 32;
	//dist = max(0, dist - (spd * frametime));

	spd *= frametime;
	if (spd > dist)
		spd = dist;
	
	this.puppet_offset += spd * normalize(diff);

	if (vlen(this.puppet_vel) < 20)
		this.puppet_vel = 0;
}

void boss2_c::turn_to_player(float spd)
{
	vector diff = (this.enemy.origin - (this.puppet.origin));
	float angwanted = vectoangles(diff)[1];
	float angdiff = angle_difference(angwanted, this.angles[1]);

	this.angles[1] += bound(-spd, angdiff, spd);
}

void boss2_c::appear_at_position(vector pos, vector ang)
{
	this.solid = SOLID_BSP;
	this.puppet.effects &= ~EF_NODRAW;
	this.puppet_offset = '0 0 0';
	this.shield_visual.alpha = 1;
	this.shield_visual.glowmod = '1 1 1';
	this.enemy = single_player;

	if (this.is_aggressive)
		this.animation_start($boss2_atelein1, $boss2_atelein10, this.anim_teleportin);
	else
		this.animation_start($boss2_telein1, $boss2_telein15, this.anim_teleportin);
	this.animlock_timestop = time + 1;

	this.v_angle[1] = ang[1];
	this.angles[1] = ang[1];
	setorigin(this, pos);
	this.puppet.origin = this.origin;
	this.travel_position = this.origin;

	// play effects
	spawn_shaker(single_player, 16, 0.8, 1024);
	float bparticle = particleeffectnum("boss2teleport");
	pointparticles(bparticle, this.origin, '0 0 0', 2);
	pointparticles(bparticle, this.origin + '0 0 128', '0 0 0', 2);
	spawn_relevelation_particles(this.origin, 16, '0.8 0.25 0.75', 1);

	soundwrath(this.puppet, CHAN_BODY, "enemies/boss2/hover_loop.ogg", 1, 0.5, 0, SOUNDFLAG_FORCELOOP, 0.15);
	soundwrath(this.puppet, CHAN_ITEM, sprintf("enemies/boss2/teleport_in%.0f.ogg", floor(random(3)) + 1), 1, 0.1, 0, 0, 0.2);

	entity ghost = boss2_ghost_spawn(this.puppet);
	ghost.colormod = '1 0.8 1';
	ghost.alpha = 1.2;
}

void boss2_c::manage_attacks(void)
{
	float delta = frametime;
	if (time < this.attack_finished) // charge up all timers slower on cooldown, so we don't lock ourselves into repetition
		delta *= 0.5;

	for(float i = 0; i < B2ATTACK_E::MAX; i++) // increment all attack scores
	{
		if !(boss2_validattacks & (1 << i)) // if this attack isn't marked as valid, ignore it!
			continue;

		this.attack_score[i] += delta;
		this.attack_score[i] = bound(0, this.attack_score[i], 30);
	}
}

void boss2_c::run_attacks(void)
{
	if (time < this.attack_finished) // we're on cooldown...
		return;

	float best_attack = -1;
	float best_score = 5;

	if (this.stage == 1 && this.force_attack > 0)
	{
		if (this.force_attack == 2)
		{
			best_attack = B2ATTACK_E::PROJECTILE_HOMING;
			best_score = 999;
		}
		else if (this.force_attack == 1)
		{
			this.animation_start($boss2_teleout1, $boss2_teleout10, this.anim_teleportout);
		}
		this.force_attack--;
	}
	else
	{
		dprint("scores: \n");
		for(float i = 0; i < B2ATTACK_E::MAX; i++)
		{
			if !(boss2_validattacks & (1 << i)) // if this attack isn't marked as valid, ignore it!
				continue;

			float score = this.attack_score[i] * random(0.95, 1.05);
			score = (this.attack_evaluate[i])(score);
			
			dprint("    ", ftos(score), "\n");

			if (score <= best_score) // ignore this attack if the score is too low!
				continue;

			best_score = score;
			best_attack = i;
		}
	}

	if (best_attack >= 0) // if we actually selected an attack, let's do it!
	{
		travel_attack--;
		travel_pause = 0.5;

		this.attack_func[best_attack](); // actually call the attack func
	}
}

void boss2_c::mainloop(void)
{
	frametime = 0.1;

	this.health = 999999; // always keep health super high
	this.flags |= FL_ONGROUND;
	this.angles = this.v_angle;

	switch(this.stage)
	{
		case 0: this.stage0_frame(); break;
		case 1: this.stage1_frame(); break;
		case 2: this.stage2_frame(); break;
	}

	// Reki (September 20 2023): Animation locks (ported from boss 3)
	if (this.animlock_start)
	{
		float do_anim = TRUE;
		if (this.animlock_think != __NULL__)
			do_anim = !this.animlock_think(); // this will return TRUE if it handled the animation logic
		
		if (do_anim && this.animlock_timestop)
			do_anim = (time > this.animlock_timestop);
		
		if (do_anim)
		{
			this.frame++;
			if (this.frame >= this.animlock_end)
			{
				this.animlock_start = 0;
				this.animlock_end = 0;
				this.animlock_think = __NULL__;
				this.animlock_timestop = 0; // for framegroups
			}
		}
	}
	else // Reki (September 20 2023): Proceed to normal states if we're not in a locked animation
	{
		switch(this.stage)
		{
			case 0: this.stage0(); break;
			case 1: this.stage1(); break;
			case 2: this.stage2(); break;
		}
	}

	if (wasfreed(this)) // ah! panic! we were freed
		return;

	// Reki (October 9 2023): make sure we're looping
	static float loop_wait;
	if !(this.hoverloop)
	{
		loop_wait = time + 2;
		this.hoverloop = TRUE;
	}
	if (loop_wait && time >= loop_wait)
	{
		loop_wait = 0;
		soundwrath(this.puppet, CHAN_BODY, "enemies/boss2/hover_loop.ogg", 1, 0.5, 0, SOUNDFLAG_FORCELOOP, 0.15);
	}
	
	// Reki (September 21 2023): update puppet
	setorigin(this.puppet, this.origin + this.puppet_offset);
	this.puppet.frame = this.frame;
	this.puppet.angles = this.angles;

	// Reki (September 20 2023): shield visual
	entity shld = this.shield_visual;
	shld.frame = this.puppet.frame;
	setorigin(shld, this.puppet.origin);
	shld.angles = this.puppet.angles;

	if (this.puppet.effects & EF_NODRAW)
		shld.effects |= EF_NODRAW;
	else
		shld.effects &= ~EF_NODRAW;

	if (shld.alpha <= 0)
	{
		shld.glowmod[0] = shld.glowmod[1] = shld.glowmod[2] = 0.001;
		shld.colormod[0] = shld.colormod[1] = shld.colormod[2] = 0.001;
	}
	//

	// Reki (September 21 2023): we fudge the angles, so collision doesn't get funky
	this.v_angle = this.angles;
	this.angles = '0 0 0';

	// Reki (September 21 2023): reign in puppet offset a bit
	this.puppet_movement();

	// Reki (September 24 2023): if we have any valid attacks, start prioritizing 'em!
	this.manage_attacks();

	this.think = this.mainloop;
	this.nextthink = time + 0.1;
}	
/* #endregion */

/* #region stage 0 */
float boss2_c::anim_wakeup()
{
	static float should_turn = 0;

	if (this.frame == $boss2_wakeup1)
	{
		if (!this.enemy)
		{
			this.enemy = single_player;
			should_turn = 1;
		}
	}

	if (should_turn)
	{
		float spd = (25 * (this.frame - this.animlock_start) / max(1, this.animlock_end - this.animlock_start));
		this.turn_to_player(spd);
	}
	else
	{
		this.turn_to_player(25);
	}

	if (this.frame < $boss2_wakeup60)
		return FALSE;

	this.pain_finished = 0;
	float bparticle = particleeffectnum("boss2teleport");
	pointparticles(bparticle, this.puppet.origin, '0 0 0', 2);
	pointparticles(bparticle, this.puppet.origin + '0 0 128', '0 0 0', 2);
	this.puppet.effects |= EF_NODRAW;
	spawn_shaker(this.puppet, 16, 1.5, 1024);
	stuffcmd(single_player, "bf 0.7 0.4 0.7 0.2 0.3\n");
	
	sound(this.puppet, CHAN_BODY, "misc/null.wav", 0, ATTN_NORM);
	soundwrath(this, CHAN_ITEM, sprintf("enemies/boss2/teleport_out%.0f.ogg", floor(random(3)) + 1), 1, 0.1, 0, 0, 0.2);
	
	// null out state
	this.attack_finished = 0;
	this.frame = $boss2_idle1;
	this.animlock_start = 0;
	this.animlock_end = 0;
	this.animlock_think = __NULL__;

	// progress to stage 1
	this.stage = 1;
	this.solid = SOLID_TRIGGER;
	this.trigger_stage(1);
	return FALSE;
}

float boss2_c::anim_rude(void) // you shot me... that was rude
{
	// Reki (September 21 2023): Copy-paste of our turning logic, but this time we smooth it based on our current frame in the animation
	float spd = (25 * (this.frame - this.animlock_start) / max(1, this.animlock_end - this.animlock_start));
	this.turn_to_player(spd);

	return FALSE;
}

void boss2_c::pain_stage0(entity atk, float amt)
{
	if !(atk.flags & FL_CLIENT)
		return;

	this.health = 999999;
	this.enemy = atk;
	
	if (this.shield_visual.alpha <= 0)
	{
		this.bloodimpact = 8;
		if (!this.animlock_start)
		{
			this.animation_start($boss2_pain1, $boss2_pain10, anim_rude);
			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/rude_vocal.ogg", 1, 0.125, 0, 0, 0.5);
		}
	}

	this.puppet_vel += (normalize(this.origin - atk.origin)) * (min(amt, 512) * 0.8);
	
	this.shield_visual.alpha = 1;
	this.shield_visual.glowmod = '3 3 3';
}

void boss2_c::stage0_frame(void)
{
	if (this.shield_visual.glowmod[0] >= 1) // shield overbright
	{
		this.shield_visual.glowmod[0] = 
		this.shield_visual.glowmod[1] = 
		this.shield_visual.glowmod[2] = max(1, this.shield_visual.glowmod[0] - (frametime * 4.46)); 
	}
}

void boss2_c::stage0(void)
{
	this.th_pain = this.pain_stage0;

	this.frame++; // idle pose
	if (this.frame < $boss2_idle1 || this.frame > $boss2_idle40)
		this.frame = $boss2_idle1;

	if (this.shield_visual.alpha >= 1)
	{
		this.shield_visual.alpha = max(1, this.shield_visual.alpha - (frametime * 1.66));
		this.turn_to_player(30);
		this.bloodimpact = 8;
	}
}
/* #endregion */

/* #region stage 1 */
void func_crystal_fadeout(void)
{
	boss2_c boss = (boss2_c)find(world, classname, "boss_guardian2");
	frametime = 0.025;
	float col = self.glowmod_x;
	col -= 0.25 * frametime;
	
	if (col <= (boss.stage == 0 ? 0.8 : 0.65) && self.health)
	{
		self.health = 0;
		if (boss)
		{
			entity o_self = self;
			self = boss;
			boss.use();
			self = o_self;

			entity lst = world;
			while(lst = find(lst, ::target, self.targetname))
			{
				if (lst.classname != "boss2_stage1_node")
					continue;
				
				lst.health = 0;
			}
		}
	}
	
	if (col > 0.3)
	{
		if (time >= self.attack_finished)
		{
			self.attack_finished = time + random(0.08, 0.3);

			if (boss)
			{
				string taglist[] = {
					"tag_h_t_left",
					"tag_headtop",
					"tag_h_t_right",
					"tag_h_b_right",
					"tag_h_b_left",
					"tag_h_t_left",
				};

				self.armorvalue = (self.armorvalue + 1) % taglist.length;
				float tag = gettagindex(boss.puppet, taglist[self.armorvalue]);
				vector to = gettaginfo(boss.puppet, tag);
				vector from;

				to[0] += random(-24, 24);
				to[1] += random(-24, 24);
				to[2] += random(-24, 24);

				vector centerpoint = (self.absmin + self.absmax) / 2;
				from[0] = random(self.absmin[0], self.absmax[0]);
				from[1] = random(self.absmin[1], self.absmax[1]);
				//from[0] = bound(self.absmin[0], to[0] + random(-256, 256), self.absmax[0]);
				//from[1] = bound(self.absmin[1], to[1] + random(-256, 256), self.absmax[1]);
				from = (from + centerpoint) / 2;
				from[2] = self.absmin[2];
				traceline(from, [from[0], from[1], self.absmax[2]], MOVE_NOMONSTERS, boss);
				from = trace_endpos;


				
				entity poof1 = boss2_spawnhandeffect();
				entity poof2 = boss2_spawnhandeffect();
				setorigin(poof1, from);
				setorigin(poof2, to);
				poof1.scale = 4;
				poof2.scale = random(2, 3);

				soundwrath(poof2, CHAN_BODY, sprintf("enemies/boss2/crystaloff_zap%.0f.ogg", floor(random(5)) + 1), 1, 0.25, random(95, 105), 0, 0.5);
				Controller_Rumble(world, 0.1, 0.8, random(60, 110));

				WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
				WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
				WriteVectorL(MSG_BROADCAST, from);
				WriteVectorL(MSG_BROADCAST, to);
				WriteByte16(MSG_BROADCAST, 1); // beam scale
				WriteShort(MSG_BROADCAST, 0); // `self` meaning the entity that owns the beam
				WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter
			}
		}
	}
	
	if (col <= 0)
	{
		col = 0.001;
		self.glowmod = [col, col, col];
		self.colormod = (self.glowmod + '1 1 1') / 2;
		return;
	}

	self.glowmod = [col, col, col];
	self.colormod = (self.glowmod + '1 1 1') / 2;

	self.think = func_crystal_fadeout;
	self.nextthink = time + frametime;
}

void func_crystal_boss_use(void)
{
	soundwrath(self, CHAN_BODY, "enemies/boss2/crystaloff_powerdown.ogg", 1, 0.125, 0, 0, 0.5);
	spawn_shaker(single_player, 8, 2, 1024);

	self.think = func_crystal_fadeout;
	self.nextthink = time + 0.025;
}

void spawnfunc_func_crystal_boss(void)
{
	if (!self.model)
	{
		remove(self);
		return;
	}

	// visuals
	self.solid = SOLID_BSP;
	setmodel(self, self.model);
	self.colormod = '1 1 1';
	self.glowmod = '1 1 1';
	self.alpha = 1;
	self.health = 1;

	// behavior
	self.use = func_crystal_boss_use;
}

float boss2_c::anim_teleportin(void)
{
	float spd = 10 * (time - (this.animlock_timestop - 1));
	this.turn_to_player(spd);

	if (this.stage < 1)
	{
		// null out state
		this.attack_finished = 0;
		this.frame = $boss2_idle1;
		this.animlock_start = 0;
		this.animlock_end = 0;
		this.animlock_think = __NULL__;

		// progress to stage 1
		this.stage = 1;
		this.solid = SOLID_BSP;
		this.trigger_stage(1);
	}
	else
	{
		this.shields_up = TRUE;
	}

	return FALSE;
}

void spawnfunc_boss2_stage1_node(void)
{
	self.health = 1; // activated
}

void trigger_boss2_position_touch(void)
{
	if !(other.flags & FL_CLIENT)
		return;

	boss2_c boss = (boss2_c)find(world, classname, "boss_guardian2");
	if (!boss)
		return;

	if (boss.node_current == self.owner)
		return;

	if (self.owner.health <= 0) // our node is no longer active... RIP :(
		return;

	boss.node_current = self.owner;
	//setorigin(boss, self.owner.origin);
	boss.appear_at_position(self.owner.origin, self.owner.angles);
};

void spawnfunc_trigger_boss2_position(void)
{
	if (!self.model || !self.target)
	{
		remove(self);
		return;
	}

	// find position node
	entity e = world;
	while(e = find(e, classname, "boss2_stage1_node"))
	{
		if (e.targetname == self.target)
			break;
	}
	self.owner = e;
	if (!self.owner)
	{
		remove(self);
		return;
	}
	//

	setmodel(self, self.model);
	self.touch = trigger_boss2_position_touch;
	init_precise_trigger_collision();
}

void boss2_c::pain_stage1(entity atk, float amt)
{
	if !(atk.flags & FL_CLIENT)
		return;

	this.health = 999999;
	this.enemy = atk;

	if (this.shields_up)
	{
		this.shield_visual.alpha = 1;
		this.shield_visual.glowmod = '3 3 3';
	}
}

void boss2_c::stage1_frame(void)
{
	if (this.puppet.effects & EF_NODRAW)
		return;
	
	this.enemy = single_player;
	this.turn_to_player(15);

	if (this.shields_up)
	{
		this.bloodimpact = 8;
		if (this.shield_visual.glowmod[0] > 1) // shield overbright
		{
			this.shield_visual.glowmod[0] = 
			this.shield_visual.glowmod[1] = 
			this.shield_visual.glowmod[2] = max(1, this.shield_visual.glowmod[0] - (frametime * 4.46)); 
		}
		else if (this.shield_visual.glowmod[0] < 1)
		{
			this.shield_visual.glowmod[0] =
			this.shield_visual.glowmod[1] =
			this.shield_visual.glowmod[2] = 1;
		}
	}
	else
	{
		this.bloodimpact = 9;
		if (this.shield_visual.glowmod[0] > 0.001) // shield powerdown
		{
			this.shield_visual.glowmod[0] = 
			this.shield_visual.glowmod[1] = 
			this.shield_visual.glowmod[2] = max(0.001, this.shield_visual.glowmod[0] - (frametime * 0.7)); 
		}
	}
}

void boss2_c::stage1(void)
{
	this.th_pain = this.pain_stage1;

	if (this.puppet.effects & EF_NODRAW)
		return;

	this.turn_to_player(10);

	this.frame++; // idle pose
	if (this.frame < $boss2_hovera1 || this.frame > $boss2_hovera30)
		this.frame = $boss2_hovera1;

	this.run_attacks();
}
/* #endregion */

/* #region stage 2 */
#define BOSS2_CIRCLERADIUS 1152
#define BOSS2_CIRCLECIRCUM (PI * BOSS2_CIRCLERADIUS * 2)
vector BOSS2_POINTONCIRCLE(__inout float progress)
{
	float circumference;
	float deg;
	vector point;

	// figure out progress relative to circumference
	circumference = BOSS2_CIRCLECIRCUM;
	progress = (progress % circumference);
	deg = (progress / circumference) * 360;

	// map to a point on X/Y plane
	point[0] = cos(DEG2RAD * deg);
	point[1] = sin(DEG2RAD * deg);
	point[2] = 0;

	return point * BOSS2_CIRCLERADIUS;
}
float BOSS2_POINTTOCIRCLE(vector diff)
{
	float yaw;
	float circumference;
	circumference = BOSS2_CIRCLECIRCUM;

	yaw = vectoyaw(normalize(diff)) % 360; // this should already be mod 360, right?
	return (yaw / 360) * circumference;
}

void boss2_stage2_playerspawn_use(void)
{
	entity lst = world;
	while(lst = findflags(lst, flags, FL_CLIENT))
	{
		stuffcmd(lst, "bf 0.52 0.5 0.6 0.6 2.5\n");
		lst.velocity = '0 0 0';
		setorigin(lst, self.origin);
		lst.angles = self.angles;
		lst.fixangle = TRUE;
	}

	remove(self);
}

void spawnfunc_boss2_stage2_playerspawn(void)
{
	self.use = boss2_stage2_playerspawn_use;
}

float boss2_c::anim_transitionstage2(void)
{
	if (this.frame < (this.animlock_end - 1))
		return FALSE;

	if (this.stage >= 2)
		return;

	this.stage = 2;
	this.trigger_stage(this.stage);

	entity lst = world;
	while(lst = find(lst, ::classname, "boss2_stage2_node")) // find initial spawn spot
	{
		if !(lst.spawnflags & 8)
			continue;

		this.appear_at_position(lst.origin, lst.angles);
		this.node_current = lst;
		this.travel_direction = 1;
		this.travel_time = random(1, 2);
		this.travel_attack = 1;
		boss2_validattacks = 0xFF;
		dprint("boss going into stage 2!\n");
		break;
	}
}

void boss2_stage2_crystal_die(void)
{
	SUB_UseTargets(); // use targets...

	void() spawnfunc_to_use;

	float item_weapons = IT_REVOLVER | IT_SHOTGUN | IT_CANNON | IT_LANCE | IT_RETCHER | IT_SPITTER;
	if (FALSE && !(single_player.items & item_weapons)) // how... the hell do we not have any weapons? drop one to avoid a soft-lock
	{
		void() weapon_drop[] = {weapon_revolver, weapon_shotgun, weapon_cannon};
		float weapon_which = floor(random(weapon_drop.length));
		spawnfunc_to_use = weapon_drop[weapon_which];
	}
	else if (single_player.health < random(30, 50)) // do we REALLY need to drop some health?
	{
		void() health_drop[] = {health_life_vial, health_life_vial, health_life_vial, health_life_vial, health_life_beaker, health_life_beaker, armor_shard};
		float health_which = floor(random(health_drop.length));
		spawnfunc_to_use = health_drop[health_which];
	}
	else // maybe we should drop some ammo?
	{
		void() ammo_drop[] = {spawnfunc_ammo_revolver, spawnfunc_ammo_shotgun, spawnfunc_ammo_cannon, spawnfunc_ammo_crystal, spawnfunc_ammo_lance, spawnfunc_ammo_lance, spawnfunc_ammo_lance};
		float ammo_which = floor(random(ammo_drop.length));
		spawnfunc_to_use = ammo_drop[ammo_which];
	}

	if (spawnfunc_to_use)
	{
		entity o_self = self;
		self = spawn();
		setorigin(self, o_self.origin + [random(-16, 16), random(-16, 16), random(32)]);
		self.angles[1] = random(360);
		spawnfunc_to_use(); // call ammo spawnfunc
		self = o_self;
	}

	death_crystal_gibs();
}

void spawnfunc_boss2_stage2_crystal(void)
{
	if (!self.model)
		self.model = "models/enemies/boss2/crys_outl.md3";
	if (self.frame < 0) // if the mapper wants the frame to be random...
		self.frame = floor(random(10));

	precache_model(self.model);
	setmodel(self, self.model);
	setsize(self, '-12 -12 -32', '12 12 32');
	self.solid = SOLID_BBOX;
	self.classname = "crystallised";

	// yoinked from crystallizer code
	crystalized(self,"tag_gib_body.tag_gib_legs_foot_l.tag_gib_legs_foot_r.tag_gib_legs_leg_l.tag_gib_legs_leg_r.tag_gib_legs_pelvis.tag_gib_head.tag_gib_body_arm_l.tag_gib_body_arm_r.tag_gib_body_hand_l.tag_gib_body_hand_r", 3.5);
	self.takedamage = DAMAGE_YES;
	self.health = 50;
	self.flags = 0;
	self.wrathflags |= FL_CRYSTAL;
	self.classentity = "corpse";
	self.th_stand = null;
	self.th_walk = null;
	self.th_run = null;
	self.ammo_crystal  = 1;
	self.th_missile = null;
	self.th_melee = null;
	self.th_pain = nullpain; // th_pain has two arguments 
	self.fake_alpha = 0.1;
	self.th_die = boss2_stage2_crystal_die;
	//monster_death_use();
	self.effects = 512;
	vector flight = getlight(self.origin);
	self.colormod_x = 0.3 + flight_x * 0.7; 
	self.colormod_y = 0.3 + flight_y * 0.7;
	self.colormod_z = 0.3 + flight_z * 0.7;
	//
}

void spawnfunc_boss2_stage2_node(void) // position node
{

}

void spawnfunc_boss2_stage2_destroy_node(void) // position node for destroy animation
{

}

void spawnfunc_boss2_stage2_destroy(void) // item to destroy during the destroy animation
{
	self.use = SUB_UseTargets;
}

void spawnfunc_boss_center(void) // center of the fight platform
{

}

float boss2_c::anim_gemshattered(void)
{
	if (this.frame != (this.animlock_end - 1))
		return FALSE;

	if (this.is_aggressive)
		this.animation_start($boss2_ateleout1, $boss2_ateleout10, this.anim_teleportout);
	else
		this.animation_start($boss2_teleout1, $boss2_teleout10, this.anim_teleportout);
	
	return FALSE;
}

static vector boss2_orbmovements_pos[] = {
	'0 0 -50',
	'20 0 90',
	'30 0 400',
	'0 0 1100',
	'0 0 1730',
};

static float boss2_orbmovements_scale[] = {
	0.2,
	8,
	4,
	2.4,
	0.001,
}

static float boss2_orbmovements_slerp[] = {
	1,
	0,
	0,
	0,
	0,
}

static float boss2_orbmovement_relative[] = {
	0,
	0.05,
	0.2,
	0.4,
	0.85,
}

const float boss2_orbmovements_period = 2;

void boss2_deathorb_think(void)
{
	if (time >= self.attack_finished)
	{
		if (self.health == 0) // first sim
		{
			self.lorigin = self.origin;
		}
		
		self.attack_finished = time + boss2_orbmovements_period;
		self.health++;
		if (self.health >= boss2_orbmovements_pos.length)
		{
			remove(self);
			return;
		}
	}

	makevectors(self.v_angle);
	float ind1 = bound(0, self.health - 1, boss2_orbmovements_pos.length - 1);
	vector pos1 = boss2_orbmovements_pos[ind1];
	float scale1 = boss2_orbmovements_scale[ind1];
	float relat1 = boss2_orbmovement_relative[ind1];
	// movement is relative
	vector move1 = self.lorigin + (v_forward * pos1[0]) + (v_right * pos1[1]) + ('0 0 1' * pos1[2]);

	float ind2 = bound(0, self.health, boss2_orbmovements_pos.length - 1);
	vector pos2 = boss2_orbmovements_pos[ind2];
	float scale2 = boss2_orbmovements_scale[ind2];
	float relat2 = boss2_orbmovement_relative[ind2];
	// movement is relative
	vector move2 = self.lorigin + (v_forward * pos2[0]) + (v_right * pos2[1]) + ('0 0 1' * pos2[2]);


	// interpolate
	float frac = (self.attack_finished - time) / boss2_orbmovements_period;
	if (boss2_orbmovements_slerp[ind2])
		frac = slerp(1, 0, frac);
	else
		frac = lerp(1, 0, frac);

	self.scale = lerp(scale1, scale2, frac);

	self.origin = lerpVector(move1, move2, frac);
	float relative = lerp(relat1, relat2, frac);

	self.origin += (single_player.origin - self.lorigin) * relative;
	self.light_lev = 768 * (1 - relative);

	self.think = boss2_deathorb_think;
	self.nextthink = time + 0.013889;
}

entity boss2_deathorb_spawn(vector ang)
{
	entity orb = spawn();
	setmodel(orb, "models/enemies/boss2/boss2_end.md3");
	//orb.avelocity[2] = 3;
	orb.scale = 10;

	orb.health = 0;
	orb.v_angle = ang;

	orb.think = boss2_deathorb_think;
	orb.nextthink = time + 0.025;

	orb.pflags = PFLAGS_FULLDYNAMIC | PFLAGS_NOSHADOW;
	orb.color = '1.4 0.2 1.3';

	//orb.effects = EF_NOPVSCULL;// | EF_NODEPTHTEST;

	return orb;
}

float boss2_c::anim_death(void)
{
	this.enemy = boss_center;

	if (this.frame == (this.animlock_end - 1))
	{
		///*
		entity ghost = boss2_ghost_spawn(this.puppet);
		ghost.alpha = this.puppet.alpha;
		ghost.spawnflags = 3;
		//*/

		this.destructor();
		return FALSE;
	}
	
	if (this.frame > $boss2_death37)
		this.puppet.alpha = max(0.001, this.puppet.alpha - 0.05);

	if (this.frame == $boss2_death37)
	{
		entity parts = spawn();
		setmodel(parts, "models/enemies/boss2/boss2_endparticles.md3");
		setorigin(parts, this.puppet.origin);
		parts.movetype = MOVETYPE_FOLLOW;
		parts.aiment = this.puppet;
		parts.angles = this.puppet.angles;// + '0 180 0';
		parts.scale = 1.5;
		this.puppet.aiment = parts;

		this.puppet.colormod = '1 0.1 0.8';
		this.puppet.effects = EF_DOUBLESIDED | EF_ADDITIVE;
		this.puppet.skin = 4;
		this.puppet.alpha = 1;

		this.stage = 3;
		this.trigger_stage(this.stage);
		killed_monsters ++;
		WriteByte(MSG_ALL, SVC_KILLEDMONSTER);
	}
	else if (this.frame == $boss2_death4)
	{
		spawn_shaker(single_player, 16, 3.5, 1024);
	}

	if (this.frame % 2 == 0)
	{
		if (this.frame < $boss2_death37)
		{
			Controller_Rumble(world, 0.5, 0.05, 180);
		}
		else
		{
			Controller_Rumble(world, 0.2, 0.75, 300);
		}
	}

	if (this.frame == $boss2_death37)
	{
		float tag = gettagindex(this.puppet, "tag_chest");
		vector tagpos = gettaginfo(this.puppet, tag);

		spawn_shaker(single_player, 16, 1.5, 1024);
		stuffcmd(single_player, "bf 0.7 0.4 0.65 0.4 0.05\n");




		spawn_relevelation_particles(tagpos, 16, '0.8 0.25 0.75', 1);
		entity orb = boss2_deathorb_spawn(this.puppet.angles);
		setorigin(orb, tagpos);
	}

	if (this.frame < $boss2_death5 || this.frame > $boss2_death36)
		return FALSE;

	if ((this.frame % 2) == 0)
	{
		entity ghost = boss2_ghost_spawn(this.puppet);
		ghost.colormod[0] += random(0.2, 0.9);
		ghost.colormod[2] -= random(0.02, 0.3);
		ghost.scale += random(0.7);
		ghost.alpha = 0.7;
		return FALSE;
	}
}

float boss2_c::anim_destruction1(void)
{
	static float destruction_wait = 0;
	if (this.frame != $boss2_destroy9)
	{
		destruction_wait = 0;
		return FALSE;
	}

	if (!destruction_wait)
	{
		// play effects
		spawn_shaker(single_player, 16, 0.5, 1024);
		float bparticle = particleeffectnum("boss2teleport");
		pointparticles(bparticle, this.puppet.origin, '0 0 0', 2);
		pointparticles(bparticle, this.puppet.origin + '0 0 128', '0 0 0', 2);
		spawn_relevelation_particles(this.puppet.origin, 16, '0.8 0.25 0.75', 1);
		single_player.r_saturation *= 0.8;
		stuffcmd(single_player, "bf 0.7 0.4 0.7 0.1 0.2\n");

		entity ghost = boss2_ghost_spawn(this.puppet);
		ghost.alpha = 0.4;

		// start waiting
		this.solid = SOLID_NOT;
		this.puppet.effects |= EF_NODRAW;

		destruction_wait = time + 3;
		return TRUE;
	}
	else
	{
		if (time > destruction_wait)
		{
			entity node = find(world, ::classname, "boss2_stage2_destroy_node");
			node.spawnflags |= 1;

			this.appear_at_position(node.origin, [0, node.angles[1], 0]);

			travel_direction = 0;
			travel_time = 0;
			travel_oncircle = BOSS2_POINTTOCIRCLE(node.origin - boss_center.origin);
			travel_position = node.origin;
			this.node_current = node;

			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/destruction_vocal.ogg", 1, 0.125, 0, 0, 0.5);
			this.animation_start($boss2_destroy10, $boss2_destroy100, this.anim_destruction2);
			return FALSE;
		}

		return TRUE;
	}
}

float boss2_c::anim_destruction2(void)
{
	travel_pause = time + 0.15;
	this.enemy = boss_center;

	if (this.frame == $boss2_destroy99)
	{
		this.animation_start($boss2_ateleout1, $boss2_ateleout10, this.anim_teleportout);
		return TRUE;
	}

	static float destruction_attack_count;
	static float destruction_beamanim;
	static entity destruction_target;
	if (this.frame == $boss2_destroy10)
	{
		destruction_attack_count = 0;
		destruction_target = world;//find(world, ::classname, "boss2_stage2_destroy");
		return FALSE;
	}

	if (this.frame == $boss2_destroy50 || this.frame == $boss2_destroy60 || this.frame == $boss2_destroy80) // do attack
	{
		entity ignore = destruction_target;
		float lowest_score = 9999;
		entity lowest_ent = world;

		entity lst = world;
		while(lst = find(lst, ::classname, "boss2_stage2_destroy"))
		{
			if (lst == ignore)
				continue;

			if (lst.type <= ignore.type)
				continue;

			if (lst.type < lowest_score)
			{
				lowest_score = lst.type;
				lowest_ent = lst;
			}
		}
		destruction_target = lowest_ent;

		if (destruction_target)
		{
			stuffcmd(single_player, "bf 0.7 0.4 0.7 0.05 0.1\n");
			Ent_UseTarget(destruction_target);
			destruction_attack_count++;

			if (destruction_attack_count >= 3)
				destruction_beamanim = time + 0.78;
			else
				destruction_beamanim = time + 0.58;
		}

		soundwrath(this, CHAN_AUTO, sprintf("enemies/boss2/destruction_firebeam%.0f.ogg", destruction_attack_count), 1, 0.25, 0, 0, 0.3);
	}

	if (destruction_target && (time < destruction_beamanim))
	{
		float tag = gettagindex(this.puppet, "tag_beam");
		vector from = gettaginfo(this.puppet, tag);
		vector to = (destruction_target.origin);

		WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
		WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
		WriteVectorL(MSG_BROADCAST, from);
		WriteVectorL(MSG_BROADCAST, to);
		WriteByte16(MSG_BROADCAST, 5); // beam scale
		WriteShort(MSG_BROADCAST, num_for_edict(this.puppet)); // `self` meaning the entity that owns the beam
		WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter
	}
	
	return FALSE;
}

void boss2_c::pain_stage2(entity atk, float amt)
{
	if !(atk.flags & FL_CLIENT)
		return;

	this.health = 999999;

	amt = min(amt, 400 - this.health_limiter);
	this.health_limiter += amt;
	this.boss_health -= amt;

	if (this.animlock_think == anim_destruction1 || this.animlock_think == anim_destruction2) // if we're in a canned animation, don't take too much damage
	{
		this.boss_health = max(this.boss_health, boss2_healthb * 0.667);
		return;
	}

	float tag = -1;
	float destruction_mode = 0;

	if (this.health_gems & 0x01) // fist (bottom) gem
	{
		if (this.boss_health <= (boss2_healtha) / 2)
		{
			this.health_gems &= ~0x01;
			tag = gettagindex(this.puppet, "tag_gem1");

			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/pain1.ogg", 1, 0.125, 0, 0, 0.5);
		}
	}
	else if (this.health_gems & 0x02) // second gem, go into phase 2
	{
		if (this.boss_health <= 0)
		{
			this.health_gems &= ~0x02;
			tag = gettagindex(this.puppet, "tag_gem2");
			destruction_mode = 1;
			
			this.boss_health = boss2_healthb + boss2_bonushealth();
			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/pain2.ogg", 1, 0.125, 0, 0, 0.5);
		}
	}
	else if (this.health_gems & 0x04) // third gem
	{
		if (this.boss_health <= (boss2_healthb) / 2)
		{
			this.health_gems &= ~0x04;
			tag = gettagindex(this.puppet, "tag_gem3");

			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/pain3.ogg", 1, 0.125, 0, 0, 0.5);
		}
	}
	else if (this.health_gems & 0x08) // last (top) gem
	{
		if (this.boss_health <= 0)
		{
			this.health_gems &= ~0x08;
			tag = gettagindex(this.puppet, "tag_gem4");
			destruction_mode = 2;

			sound(this.puppet, CHAN_BODY, "misc/null.wav", 0, ATTN_NORM);
			soundwrath(this.puppet, CHAN_VOICE, "enemies/boss2/die1.ogg", 1, 0.125, 0, 0, 0.7);
		}
	}

	if (tag >= 0)
	{
		vector tagloc = gettaginfo(this.puppet, tag);
		pointparticles(particleeffectnum("wretch_explo"), tagloc, '0 0 0', 3);
		this.puppet.skin++;
		travel_time = 0;
		travel_speed = 0;

		if (destruction_mode == 1) // move to destruction scene
		{
			this.is_aggressive = TRUE;
			this.animation_start($boss2_destroy1, $boss2_destroy10, this.anim_destruction1);
		}
		else if (destruction_mode == 2) // boss is dying
		{
			this.animation_start($boss2_death1, $boss2_death50, this.anim_death);
		}
		else // just play pain animation
		{
			if (this.health_gems & 0x04)
				this.animation_start($boss2_staggera1, $boss2_staggera30, this.anim_gemshattered);
			else
				this.animation_start($boss2_staggerb1, $boss2_staggerb30, this.anim_gemshattered);
		}

		entity ghost = boss2_ghost_spawn(this.puppet);
		ghost.alpha = 1.5;
		ghost.scale = 1.7;
		ghost.colormod = '0.2 0.03 0.09';
	}
}

float boss2_anim_stage2(void)
{
	boss2_c boss = (boss2_c)self;
	boss.stage2();
	return FALSE;
}

float boss2_c::anim_appearwait(void)
{
	if (this.frame < (this.animlock_end - 1))
		return FALSE;

	entity locations_list = world;
	float locations_total = 0;

	entity oldent = world, ent = world;
	while(ent = find(ent, ::classname, "boss2_stage2_node")) // find a valid spawn location
	{
		if !(ent.spawnflags & 4)
			continue;

		ent.chain = world;
		if (oldent)
			oldent.chain = ent;
		else
			locations_list = ent;

		oldent = ent;
		locations_total++;
	}

	//dprint(ftos(locations_total), "\n");
	//dprint(etos(locations_list), "\n");
	stuffcmd(single_player, "bf 0.7 0.4 0.7 0.15 0.15\n");

	if (locations_list)
	{
		ent = locations_list;
		float threshold = floor(random(locations_total));
		for(float i = 0; i < threshold; i++) { ent = ent.chain; };

		this.appear_at_position(ent.origin, [0, ent.angles[1], 0]);
		this.animlock_think = boss2_anim_stage2;
		this.travel_position = this.origin;
		this.node_current = ent;

		this.travel_direction = round(random());
		this.travel_time = random(1, 2);
		this.travel_attack = ceil(random(1, 3));
	}

	return FALSE;
}

float boss2_c::anim_teleportout(void)
{
	if (this.frame != $boss2_teleout9 && this.frame != $boss2_ateleout9 && this.frame != $boss2_scowl24)
		return FALSE;

	// play effects
	spawn_shaker(single_player, 16, 0.5, 1024);
	float bparticle = particleeffectnum("boss2teleport");
	pointparticles(bparticle, this.puppet.origin, '0 0 0', 2);
	pointparticles(bparticle, this.puppet.origin + '0 0 128', '0 0 0', 2);
	spawn_relevelation_particles(this.puppet.origin, 16, '0.8 0.25 0.75', 1);
	single_player.r_saturation *= 0.8;
	stuffcmd(single_player, "bf 0.7 0.4 0.7 0.1 0.2\n");

	sound(this.puppet, CHAN_BODY, "misc/null.wav", 0, ATTN_NORM);
	soundwrath(this, CHAN_ITEM, sprintf("enemies/boss2/teleport_out%.0f.ogg", floor(random(3)) + 1), 1, 0.1, 0, 0, 0.2);

	entity ghost = boss2_ghost_spawn(this.puppet);
	ghost.alpha = 0.4;

	// start waiting
	this.solid = SOLID_NOT;
	this.puppet.effects |= EF_NODRAW;
	if (this.stage == 2)
	{
		this.animation_start(1, ceil(20 + random(20)), this.anim_appearwait);
	}
	else if (this.stage == 1)
	{
		if (levers_remaining <= 0)
			this.animation_start(1, ceil(boss2_stage2transitiontime * 10), this.anim_transitionstage2);
	}
	return FALSE;
}

void boss2_c::stage2_frame(void)
{
	boss_center = find(world, ::classname, "boss_center");

	// slow damage intake to max 400dps
	if (this.health_limiter > 0)
		this.health_limiter -= frametime * 400;
	else
		this.health_limiter = 0;

	//
	if (node_current.spawnflags & 1) // circling
	{
		if (travel_time > 0)
		{
			if (travel_speed < 800 && travel_pause <= 0)
			{
				travel_speed += 1200 * frametime;
				travel_speed = bound(180, travel_speed, 600);
			}
			travel_time -= frametime;
		}
		else
		{
			travel_time = 0;
			if (travel_speed > 60)
			{
				travel_speed -= (travel_speed * 0.98) * frametime;
			}
			else
			{
				travel_speed = 0;
			}

			// force some travel time if we're blocked by a pillar
			tracebox(travel_position, '-64 -64 -64', '64 64 64', travel_position + normalize(boss_center.origin - travel_position) * 256, MOVE_NOMONSTERS, this);
			if (trace_fraction < 1)
			{
				travel_speed = 320;
			}
		}

		float spd = travel_speed * frametime;
		travel_oncircle += travel_direction ? spd : -spd;

		vector circle_pos = boss_center.origin + BOSS2_POINTONCIRCLE(travel_oncircle);
		travel_position = [circle_pos[0], circle_pos[1], node_current.origin[2]];	
		//setorigin(this, this.origin);
	}
	else // pathfinding
	{
		if !(node_next)
		{
			if (travel_direction)
			{
				if (node_current.connect2)
					node_next = find(world, ::targetname, node_current.connect2);
				else
					node_next = find(world, ::targetname, node_current.connect1);
			}
			else
			{
				if (node_current.connect1)
					node_next = find(world, ::targetname, node_current.connect1);
				else
					node_next = find(world, ::targetname, node_current.connect2);
			}
		}

		if (node_next)
		{
			travel_speed = 700;
			float spd = travel_speed * frametime;
			travel_position += normalize(node_next.origin - travel_position) * spd;
			//setorigin(this, this.origin);
			if (vlen(node_next.origin - travel_position) <= max(32, spd))
			{
				node_current = node_next;
				node_next = world;

				if (node_current.spawnflags & 1)
					this.travel_oncircle = BOSS2_POINTTOCIRCLE(travel_position - boss_center.origin);
			}
		}
	}
	//

	// move torwards travel_position
	vector dir = normalize(this.origin - travel_position);
	this.origin = lerpVector(this.origin, travel_position, 0.9 * frametime);
	setorigin(this, this.origin);
	//

	if (this.shield_visual.glowmod[0] > 0.01) // shield down
	{
		this.shield_visual.glowmod[0] = 
		this.shield_visual.glowmod[1] = 
		this.shield_visual.glowmod[2] = max(0.01, this.shield_visual.glowmod[0] - (frametime * 4)); 
	}

	this.turn_to_player(12);
}

void boss2_c::stage2(void)
{
	this.th_pain = this.pain_stage2;
	this.bloodimpact = 9;
	boss_center = find(world, ::classname, "boss_center");

	if (travel_pause > 0)
		travel_pause = max(0, travel_pause - frametime);
	
	if (node_current.spawnflags & 1)
	{
		if (travel_time <= 0)
		{
			travel_time = 0;
			if (travel_attack <= 0) // we need to spawn somewhere else!
			{
				//this.solid = SOLID_NOT;
				//this.puppet.effects |= EF_NODRAW;
				//this.animation_start(1, ceil(10 + random(30)), this.anim_appearwait);
				if (this.is_aggressive)
					this.animation_start($boss2_ateleout1, $boss2_ateleout10, this.anim_teleportout);
				else
					this.animation_start($boss2_teleout1, $boss2_teleout10, this.anim_teleportout);
			}
		}

		if ((travel_attack) && (travel_speed < 110)) // we're ready to attack, so do it!
		{
			float o_travel_attack = travel_attack;
			this.run_attacks();
			
			if (travel_attack && travel_attack != o_travel_attack) // if travel_attack has changed
			{
				if (random() < 0.2)
					travel_direction = !travel_direction;
				
				travel_time = random(3, 6);
				self.attack_finished = max(self.attack_finished, time + (travel_time * 0.4));
			}
		}
	}

	if (!this.animlock_start) // we may be running an anim with a wrapper, so don't mess with the frames
	{
		float anim_offset = 0;

		this.frame++;
		if (this.travel_speed >= 650)
		{
			this.enemy = boss_center;
			if (this.is_aggressive)
				anim_offset = $boss2_asstrf_r1 - $boss2_sstrf_r1;

			if (this.frame < AGG($boss2_sstrf_l1) || this.frame > AGG($boss2_sstrf_r30)) // if we're outside of the strafe anims, play the transition
			{
				if (travel_direction)
					this.animation_start(AGG($boss2_sstrf_r1), AGG($boss2_sstrf_r4), boss2_anim_stage2);
				else
					this.animation_start(AGG($boss2_sstrf_l1), AGG($boss2_sstrf_l4), boss2_anim_stage2);
			}
			else
			{
				if (travel_direction)
				{
					if (this.frame < AGG($boss2_sstrf_r3) || this.frame > AGG($boss2_sstrf_r27))
						this.frame = AGG($boss2_sstrf_r3);
				}
				else
				{
					if (this.frame < AGG($boss2_sstrf_l3) || this.frame > AGG($boss2_sstrf_l27))
						this.frame = AGG($boss2_sstrf_l3);
				}
			}
		}
		else
		{
			this.enemy = single_player;
			if (this.is_aggressive)
				anim_offset = $boss2_asstrf_r1 - $boss2_sstrf_r1;
			
			if (this.frame > AGG($boss2_sstrf_r1) && this.frame < AGG($boss2_sstrf_r30)) // if we're fast strafing, transition out
			{
				this.animation_start(AGG($boss2_sstrf_r28), AGG($boss2_sstrf_r30), boss2_anim_stage2);
			}
			else if (this.frame > AGG($boss2_sstrf_l1) && this.frame < AGG($boss2_sstrf_l30)) // if we're fast strafing, transition out
			{
				this.animation_start(AGG($boss2_sstrf_l28), AGG($boss2_sstrf_l30), boss2_anim_stage2);
			}
			else
			{
				if (this.is_aggressive)
					anim_offset = $boss2_hoverb1 - $boss2_hovera1;
				if (this.frame < AGG($boss2_hovera1) || this.frame > AGG($boss2_hovera30))
					this.frame = AGG($boss2_hovera1);
			}
		}
	}
}
/* #endregion */

/* #endregion */
#endif
#if 0
/* #region Old code */

void(vector org,vector dir, float proj_angles, entity ownerproj, float proj_type,float projdelay, string tagname) launch_projectile_guardian2 = 
{ 
	local entity guardian2_projectile;
	monstersound3("enemies/wretch/fire", 5, CHAN_AUTO);	
	guardian2_projectile = spawn();	
	guardian2_projectile.origin = org;
	if((ownerproj.magnetized != 0))
		guardian2_projectile.magnetized = ownerproj.magnetized;

	guardian2_projectile.owner = ownerproj;
	guardian2_projectile.effects = EF_NODRAW;
	guardian2_projectile.wrathflags += FL_PROJECTILE;
	guardian2_projectile.solid = SOLID_TRIGGER;
	guardian2_projectile.scale = 2;
	if(proj_type == 1)
		guardian2_projectile.scale = 3;
	if(proj_type == 2)
		guardian2_projectile.scale = 4;
		

	guardian2_projectile.traileffectnum = particleeffectnum("proj_guardian1_trail1");

	guardian2_projectile.colormod = '1.5 0.2 1';

	if(proj_type == 1)
	{
		guardian2_projectile.colormod = '1.2 0.2 1';
		guardian2_projectile.traileffectnum = particleeffectnum("proj_guardian1_trail2");
	}

	if(proj_type == 2)
	{
		guardian2_projectile.colormod = '1.5 0.2 1';
		guardian2_projectile.traileffectnum = particleeffectnum("proj_guardian1_trail3");
	}

	guardian2_projectile.touch = projectile_touch_wre;
	guardian2_projectile.classname = "projectile";
	guardian2_projectile.lifetime  = time + 7.5;
	guardian2_projectile.enemy = ownerproj.enemy;

	local entity oself;oself = self;self = guardian2_projectile;
	sound7(self, CHAN_WEAPON, "enemies/wraith/proj_loop1.ogg", 1, 0.25, 80 + random() *5, 0);
	self = oself;

	setmodel(guardian2_projectile, "models/projectiles/proj_wretch.md3");
	setsize(guardian2_projectile, '-12 -12 -12', '12 12 12');

	guardian2_projectile.angles = vectoangles(dir) ;

	float angle_y_compensation;
	if(tagname == "tag_left_hand")
		angle_y_compensation = -2;
	if(tagname == "tag_right_hand")
		angle_y_compensation = 1.79;

	guardian2_projectile.angles_y -= (proj_angles * 0.25) + angle_y_compensation ;
	makevectors2 (guardian2_projectile.angles);
	dir = v_forward;


	if(ownerproj.ammo_cannon >= 0 )
	{
		float addspeed = ownerproj.ammo_cannon * 16;
	}

	guardian2_projectile.velocity = dir * (boss1_proj1_vel + addspeed);

	if(guardian2_projectile.magnetized >= 1)
	{
	  	guardian2_projectile.velocity = dir * (boss1_proj2_vel);
		guardian2_projectile.guardian_shoot_cnt = boss1_proj2_homingcount; 
	}
	guardian2_projectile.oldvelocity = guardian2_projectile.velocity;
	guardian2_projectile.think = projectile_guardian1_prethink;
	guardian2_projectile.nextthink = time + (projdelay);
};

void(string tagname, float offset,float projdelay) guardian2_attack_spread =
{
	ai_face_boss();
	self.colormod = '0 0 0';
	float playerspeed = (vlen (self.enemy.velocity)) * 0.125;
	vector nextpos = (normalize (self.enemy.velocity)) * playerspeed ;	
	vector newplayerorg =self.enemy.origin + nextpos;	
	vector org = tag_origin(tagname, self);
	makevectors (self.angles);
	
	vector aim_org = self.origin;
	aim_org_z = org_z;

	vector player_offset = '0 0 12';

	if((self.classname == "boss_guardian2") &&(self.origin_z > (self.enemy.origin_z + 12))) 
		newplayerorg_z += random (24,64);
	else
		newplayerorg_z += random (-64,24);

		newplayerorg_x += random (-8,8);
		newplayerorg_y += random (-8,8);


	if(self.ammo_cannon >= 0 )
		newplayerorg_z = self.enemy.origin_z + nextpos_z;

	if(self.magnetized == 1)
		player_offset += '0 0 92';

	if(self.origin_z < (self.enemy.origin_z + 1))
	{
		if(self.magnetized == 1)
			player_offset += '0 0 256';
		else
		{
			if(self.bosscnt == 1)
				player_offset += '0 0 24';
		}
		if(((self.origin_z + 800) < (self.enemy.origin_z)) && (self.magnetized == 1))
			player_offset += '0 0 186';
	}

	if(self.origin_z > (self.enemy.origin_z + 64)) 
	{
		if(self.bosscnt == 3)
			player_offset = '0 0 -32';
		else
			player_offset = '0 0 -92';

		if(self.magnetized == 1)
		{
			if(self.origin_z > (self.enemy.origin_z + 350)) 
			{				
				player_offset += '0 0 -256';
				self.magnetized = 2;
			}		
			if(self.origin_z > (self.enemy.origin_z + 700)) 
					player_offset += '0 0 -128';
		}	
		else
		{
			if(self.bosscnt == 2)
				player_offset += '0 0 64';
		}
	}

	vector dir = normalize( (newplayerorg +player_offset) - aim_org  );
	org += v_right * (offset * 1.25);
	
	if(tagname == "tag_left_hand")
		org += v_up * (offset * 0.75);
	else
		org += v_up * (offset * -0.75);
	
	float proj_type = 0;
	if(self.vweaponframe == 10)
		proj_type =  1;
	if(self.vweaponframe == 12)
		proj_type =  2;

//void(vector org, float radius, float lifetime, vector color) te_customflash = #417;

	if(self.magnetized == 1)
		te_customflash (org, 256,1,'0.35 0.35 1');
	else
		te_customflash (org, 170,0.75,'1 0.5 0.5');


	launch_projectile_guardian2(org, dir, offset,self,proj_type,projdelay, tagname);
};

void()guardian2_prealert;
void()guardian2_alert;
void()guardian2_idle;
void(vector destination) boss2firegrenade;

void() boss2_alphafade =
{
	self.alpha -= 0.05;
	self.scale -= 0.5;

	if(self.alpha < 0.05)
	{
		self.alpha -1;
		self.think = SUB_Remove;
	}
	else
		self.think = boss2_alphafade;
	self.nextthink = time + 0.025;

};

void(entity e) guardian2_teleport_effects =
{
	spawn_shaker(e,16,1.5,2048);  
	string tmpstr;
	float v = random() *5;
	if (v < 1)
		tmpstr = "fx/tele1.ogg";
	else if (v < 2)
		tmpstr = "fx/tele2.ogg";
	else if (v < 3)
		tmpstr = "fx/tele3.ogg";
	else if (v < 4)
		tmpstr = "fx/tele4.ogg";
	else
		tmpstr = "fx/tele5.ogg";
	sound7(e, CHAN_AUTO, tmpstr, 1, 0.125, 50,0);
	sound7(e, CHAN_AUTO, tmpstr, 1, 0.125, 120,0);
	local float bparticle;
	bparticle = particleeffectnum("boss2teleport");
	pointparticles(bparticle, e.origin, '0 0 0', 2);
	pointparticles(bparticle, e.origin + '0 0 128', '0 0 0', 2);

	spawn_relevelation_particles(e.origin,24,'0.8 0.25 0.75',1);
	spawn_relevelation_particles(e.origin + '0 0 128',12,'0.8 0.25 0.75',1);

	entity muzzle = spawn();
	setmodel (muzzle,"models/projectiles/proj_wretch.md3");
	muzzle.scale = 25;
	muzzle.colormod = '0.8 0 0.75';
	setorigin (muzzle, e.origin + '0 0 64');
	muzzle.think = boss2_alphafade;
	muzzle.alpha = 1.25;
	muzzle.nextthink = time + 0.5;
};

float boss2_distance = 1560;

float(float pdist) TeleportNearestBossPath = 
{ 
	local entity head, near;
	local float dist, low;
	vector tdest;
	low = pdist;	
	head = find(world, classname, "boss_path");
	if(self.enemy == single_player)
		tdest = single_player.origin;
	else
		tdest = self.origin;
	if (!head)
		return FALSE;
	while (head) 
	{
		dist = vlen(head.origin - tdest);
		float allowteleport = 0;
		if((self.bosscnt < 3) && (head.using == 1))
			allowteleport = 1;
		if(self.bosscnt >= 3)
			allowteleport = 1;
		if ((dist < low) && (allowteleport == 1))
		{
			low = dist;
			near = head;
		}
		head = find(head, classname, "boss_path");
	}
	if (near)
	{
		self.finaldest = near.origin;
		//setorigin (self, near.origin);
		if(pdist != 999999)
			self.evading_time = time + random (5,7);
		return TRUE;
	}
	else
	{
		self.finaldest = '0 0 0';
		return FALSE;
	}
};


void() guardian2_teleportbloop =
{
	if(self.effects != EF_NODRAW)
	{	
		self.effects = EF_NODRAW;
		guardian2_teleport_effects(self);
		setorigin (self, '0 0 0');
	}
	if(TeleportNearestBossPath(1560) == TRUE)
	{
		setorigin (self, self.finaldest);
		guardian2_teleport_effects(self);
		self.enemy = single_player;
		self.effects = 0;
		self.think = guardian2_prealert;
		self.state = 0;
	}
	else
		self.think = guardian2_teleportbloop;
	self.nextthink = time  + 0.1;
};

void()guardian2_teleportb =
{
	self.frame = $boss2_teleportb;
	self.nextthink = time  + 1;
	self.think = guardian2_teleportbloop;
};

void() guardian2_paina =
{
	self.frame = $boss2_paina;
	self.nextthink = time  + 1.5;
	self.think = guardian2_teleportbloop;
};

void() guardian2_painb =
{
	self.frame = $boss2_painb;
	self.nextthink = time  + 1.5;
	self.pain_finished = random(2,3);
	self.colormod = '1 0 0';
	self.think = guardian2_prealert;
};

void(vector destination) boss2firegrenade =
{
    local entity missile;
    self.effects = self.effects;
	local vector tagorg;
	local float tagindex;
	tagindex = gettagindex(self, "tag_chest");
	tagorg = gettaginfo(self, tagindex);
    missile = spawn ();
    missile.owner = self;
    missile.movetype = MOVETYPE_BOUNCE;
    missile.solid = SOLID_TRIGGER;
	missile.wrathflags += FL_PROJECTILE;
	missile.velocity = normalize(destination - tagorg);
	missile.velocity = missile.velocity * random(256,768);
	missile.velocity_z = random(128,368);
	missile.gravity = 0.75;
	missile.enemy = self.enemy;
	missile.traileffectnum = particleeffectnum("bruteprojparticle");
    missile.angles = vectoangles(missile.velocity);
    missile.touch = brutegrenadetouch;
    missile.lifetime = time + 15;
	missile.nextthink = time + 0.1;
	missile.color = '0.75 0.5 0.2';
	missile.pflags = 192;
	missile.style = 3;
	missile.light_lev = 64;
    missile.think = brutegrenadethink;
	setmodel(missile, "models/projectiles/proj_wretch.md3");
    setsize (missile, '-5 -5 -5', '5 5 5');
	te_customflash (tagorg,92,0.55,'0.75 0.6 0.2');
    setorigin (missile, tagorg);
};
.vector boss2shotorigin;
void() guardian2_attacke =
{
	ai_face_boss();
	self.frame = $boss2_attackc;
	self.attack_finished = time + 1.5 + random(2);
	self.magnetized = 0;
	float shotcount = 20;
	vector rangles;
	vector forigin = self.origin;
	forigin_z = self.origin_z;
	
	float dist = vlen(forigin - self.enemy.origin);
	makevectors2(self.angles);

	while (shotcount)
	{
		vector shotorigin = self.origin + v_forward * dist + rangles;
		shotorigin_z = self.enemy.origin_z;
		boss2firegrenade(shotorigin);
		pointparticles(particleeffectnum("brutemuzzle"), shotorigin, '0 0 0', 3);

		shotcount --;
		rangles_x = random(-24,24)* shotcount;
		rangles_y = random(-24,24)* shotcount;
		rangles_z = random(-24,24)* shotcount;
	}
	self.think = guardian2_prealert;
	self.nextthink = time  + 1.5;
};

void() guardian2_attackd =
{
	ai_face_boss();
	self.frame = $boss2_attackc;
	self.attack_finished = time + 1.5 + random(2);
	self.magnetized = 0;
	float shotcount = 16;
	vector rangles;

	vector forigin = self.origin;
	forigin_z = self.origin_z;
	
	float dist = vlen(forigin - self.enemy.origin);
	makevectors2(self.angles);
	while (shotcount)
	{
		vector shotorigin = self.origin + v_forward * dist + rangles;
		shotorigin_z = self.enemy.origin_z;
		boss2firegrenade(shotorigin);
		pointparticles(particleeffectnum("brutemuzzle"), shotorigin, '0 0 0', 3);

		shotcount --;
		rangles_x = random(-24,24)* shotcount;
		rangles_y = random(-24,24)* shotcount;
		rangles_z = random(-24,24)* shotcount;
	}
	self.think = guardian2_prealert;
	self.nextthink = time  + 1.5;
};
void() guardian2_attackc =
{
	ai_face_boss();
	self.frame = $boss2_attackc;
	self.attack_finished = time + 1.5 + random(2);
	self.magnetized = 0;
	float shotcount = 12;
	vector rangles;
	vector forigin = self.origin;
	forigin_z = self.origin_z;
	
	float dist = vlen(forigin - self.enemy.origin);
	makevectors2(self.angles);
	while (shotcount)
	{
		
		vector shotorigin = self.origin + v_forward * dist + rangles;
		shotorigin_z = self.enemy.origin_z;
		boss2firegrenade(shotorigin);
		pointparticles(particleeffectnum("brutemuzzle"), shotorigin, '0 0 0', 3);

		shotcount --;
		rangles_x = random(-24,24)* shotcount;
		rangles_y = random(-24,24)* shotcount;
		rangles_z = random(-24,24)* shotcount;
	}
	self.think = guardian2_prealert;
	self.nextthink = time  + 1.5;
};

void() guardian2_attackb_1 =
{
	ai_face_boss();
	self.frame ++;
	self.vweaponframe ++;
	ai_face_boss();

	if(behindapillar (self.enemy.origin))
	{
		float r_spread = random();
		if(r_spread < 0.5)
			r_spread = -48;
		else
			r_spread = 48;
	}
	else
		r_spread = random(-12,12);
	self.magnetized = 1;

	if(self.vweaponframe == 10)
	{
		self.attack_finished = time + 2.5 + random(2);
		if(self.bosscnt < 3)
			guardian2_attack_spread("tag_chest",r_spread,0);
		else
		{
			guardian2_attack_spread("tag_chest",-82 +r_spread,0);
			guardian2_attack_spread("tag_chest",0+r_spread,0);
			guardian2_attack_spread("tag_chest",92+r_spread,0);
		}
	}
	if(self.vweaponframe >= 12)
		self.think = guardian2_prealert;
	else
		self.think = guardian2_attackb_1;

	self.nextthink = time  + 0.1;
};


void() guardian2_attackb =
{
	ai_face_boss();
	self.magnetized = 1;
	self.frame = $boss2_attackb1; 
	self.vweaponframe = 1;	
	self.think = guardian2_attackb_1;
	self.nextthink = time  + 0.1;
};

void()guardian2_attacka;
void() guardian2_attacka_1 =
{
	self.frame ++;
	self.vweaponframe ++;
	ai_face_boss();
	if(self.vweaponframe == 12)
	{
		guardian2_attack_spread("tag_h_t_left",-64,0);
		guardian2_attack_spread("tag_h_m_left",-48,0);
		guardian2_attack_spread("tag_h_m_left",-32,0.3);
		guardian2_attack_spread("tag_h_b_left",-16,0.3);
		guardian2_attack_spread("tag_h_b_left", 0,0);
		guardian2_attack_spread("tag_h_b_right", 0,0);
		guardian2_attack_spread("tag_h_b_right", 16,0.3);
		guardian2_attack_spread("tag_h_m_right", 32,0.3);
		guardian2_attack_spread("tag_h_m_right", 48,0);
		guardian2_attack_spread("tag_h_t_right", 64,0);
	}
	if(self.vweaponframe >= 22)
	{
		self.attack_finished = time + 0.5+ random(1.5);
		self.think = guardian2_prealert;
		self.nextthink = time  + 0.1;
	}
	else
	{
		self.think = guardian2_attacka_1;
		self.nextthink = time  + 0.1;
	}
};

void() guardian2_attacka =
{
	ai_face_boss();
	self.magnetized = 0;
	self.frame = $boss2_attacka1; 
	self.vweaponframe = 1;	
	self.think = guardian2_attacka_1;
	self.nextthink = time  + 0.1;
};

void()guardian2_alert =
{
	self.frame = $boss2_hovera;
	ai_face_boss();
	self.colormod = '1 1 1';
	if(self.state == 1)
		self.think = guardian2_teleportb;
	else
	{
		if((time > self.attack_finished) && (!(self.enemy.flags &FL_NOTARGET)))
		{
			if(self.bosscnt < 3)
			{
				if(visible(self.enemy))
				{
					self.think = guardian2_attacka;
				}
				else
				{
					self.think = guardian2_attackb;
				}
			}
			else
			{
				vector rorg = self.origin;
				rorg_z = self.enemy.origin_z;
				float dist = vlen (rorg - self.enemy.origin);
				if(dist < 512) 
				{
					self.think = guardian2_attackc;
				}
				if(dist < 960)
				{
					self.think = guardian2_attackd;
				}
				if(dist < 1360)
				{
					self.think = guardian2_attacke;
				}
				if(dist >= 1768)
				{
					self.think = guardian2_attackb;
				}
			}
		}
		else
			self.think = guardian2_alert;
	}
	self.nextthink = time  + 0.025;
};
void() guardian2_prealert =
{
	self.frame = $boss2_hovera;
	ai_face_boss();
	self.think = guardian2_alert;
	self.nextthink = time  + 0.1;
};



void() guardian2_postteleport =
{

	guardian2_teleport_effects(self);
	self.think = guardian2_prealert;
	self.nextthink = time + 0.025;
};



void() guardian2_teleport =
{
	spawn_shaker(self,16,1.5,1024);  
	string tmpstr;
	float v = random() *5;
	if (v < 1)
		tmpstr = "fx/tele1.ogg";
	else if (v < 2)
		tmpstr = "fx/tele2.ogg";
	else if (v < 3)
		tmpstr = "fx/tele3.ogg";
	else if (v < 4)
		tmpstr = "fx/tele4.ogg";
	else
		tmpstr = "fx/tele5.ogg";
	sound7(self, CHAN_AUTO, tmpstr, 1, 0.25, 75,0);
	local float bparticle;
	bparticle = particleeffectnum("boss2teleport");
	pointparticles(bparticle, self.origin, '0 0 0', 1);
	pointparticles(bparticle, self.origin + '0 0 128', '0 0 0', 1);
	spawn_relevelation_particles(self.origin,16,'0.8 0.25 0.75',1);
	spawn_relevelation_particles(self.origin + '0 0 128',16,'0.8 0.25 0.75',1);
	float distalpha;
	distalpha = vlen (self.origin - self.enemy.origin);
	distalpha =  768 /distalpha ;
	if(distalpha > 1)
		distalpha = 1;
	
	stuffcmd (self.enemy, strcat(("bf 0.8 0.25 0.75 "),ftos(distalpha * 0.5) ,(" 0.45\n")));
	spawn_tfog(self.origin);


	entity muzzle = spawn();
	setmodel (muzzle,"models/projectiles/proj_wretch.md3");
	muzzle.scale = 15;
	muzzle.colormod = '0.8 0 0.75';
	setorigin (muzzle, self.origin + '0 0 64');
	muzzle.think = boss2_alphafade;
	muzzle.alpha = 1.25;
	muzzle.nextthink = time + 0.5;
	
	te_customflash(self.origin, 768, 1, '1 0 1');
	
	setorigin (self, self.finaldest);
	self.enemy = single_player;
	self.think = guardian2_postteleport;
	self.nextthink = time; 
};

void()guardian2_teleporta =
{
	spawn_shaker(self,16,0.5,1024);  
	te_customflash(self.origin + '0 0 64', 192, 1, '0.9 0.25 0.75');
	pointparticles(particleeffectnum("boss2preteleport"), self.origin +'0 0 64', '0 0 0', 1);
	TeleportNearestBossPath(999999);
	self.frame = $boss2_teleporta;
	self.nextthink = time  + 1;
	self.think = guardian2_teleport;
};

void() guardian2_wakeupa =
{
	spawn_shaker(self,4,5,1024);  
	self.frame = $boss2_wakeup;
	self.nextthink = time + 5;
	self.think = guardian2_teleporta;
};

void() guardian2_idle = 
{
	self.frame ++;
	if(self.frame >= $boss2_idle40)
		self.frame = $boss2_idle1;
	if((self.using == 1))
		player_enemy();
	if(!self.enemy)
		self.think = guardian2_idle;
	else
		self.think = guardian2_wakeupa;
	self.nextthink = time + 0.1;
};

void() guardian2_preidle =
{
	self.frame = $boss2_idle1;
	self.think = guardian2_idle;
	self.nextthink = time  + 0.1;
};

void()nodrawcontroller_think =
{
	float bosscounterdist;
	bosscounterdist = 1560;
	if((self.owner.enemy != single_player) || (self.owner.evading_time > time))
		self.owner.state = 0;
	else
	{
		float dist = vlen (self.owner.origin - self.owner.enemy.origin);
 
		if(dist < bosscounterdist) 
		{
			if(self.owner.state == 1)
				self.owner.state = 0;
		}
		else
		{
			if(self.owner.state == 0)
				self.owner.state = 1;
		}
	}
	if(self.owner.bosscnt >= 3)
		self.think = SUB_Remove;
	else
		self.think = nodrawcontroller_think;

	self.nextthink = time + 0.05;
};

void() boss_guardian2_die =
{
	float lgibcount = 32;
	while(lgibcount > 0)
	{
		vector org;
		org_x = random(self.mins_x, self.maxs_x);
		org_y = random(self.mins_y, self.maxs_y);
		org_z = random(self.mins_z, self.maxs_z);
		org += self.origin;
		vector dir = normalize( org - self.origin);
		vector vel = dir *  random(512,1024);
		vel_z += 256;
		SpawnBossGib2(org,vel);
		lgibcount --;
	}
	float particleclount = 96;
	while(particleclount > 0)
	{
		entity secret_mark2;
		secret_mark2 = spawn();
		org_x = random(self.mins_x, self.maxs_x);
		org_y = random(self.mins_y, self.maxs_y);
		org_z = random(self.mins_z, self.maxs_z);
		org += self.origin;

		secret_mark2.origin = org;

		float r = random();
		if(r > 0.3)
			secret_mark2.colormod = '0.175 0.35 1';
		else
			secret_mark2.colormod = '0.25 0.25 0.75';
		secret_mark2.scale = random(7,15);
		secret_mark2.alpha = random(1.5,3);
		setmodel(secret_mark2,"models/artifacts/effects/revelation_particle.md3");
		secret_mark2.wrathflags += FL_GARBAGE;
		secret_mark2.effects = 512 + EF_DOUBLESIDED +EF_ADDITIVE;
		secret_mark2.solid = SOLID_NOT;
		secret_mark2.movetype = MOVETYPE_NOCLIP;
		makevectors (single_player.v_angle);

		secret_mark2.velocity = v_right * random(-256,256) * 7;

		secret_mark2.velocity_z = random(-256,256)* 3;

		secret_mark2.avelocity_z = random(-512,512);
		secret_mark2.angles_x = random (0,360);
		secret_mark2.angles_y = random (0,360);
		secret_mark2.angles_z = random (0,360);
		//setorigin (secret_mark2,dir);
		secret_mark2.think = spawned_relevelation_particles_think;
		secret_mark2.nextthink = time + 1.5; 
		particleclount --;
	}
	spawn_shaker(self,32,1.25,768);  

	te_customflash (self.origin,512,0.55,'0.9 0.9 1');
 	stuffcmd (single_player, "bf 0.95 0.95 1 0.9 0.45\n");
	self.attached_cloud.count = 0.05;
	self.think = SUB_Remove;
	self.effects = EF_NODRAW;
	//self.attached_cloud.count = 0;
	self.nextthink = time + 0.5;
	entity boss2portal = spawn();
	boss2portal.origin = self.origin;
	setmodel(boss2portal, "models/portals/portal_level_to_hub.md3");
	boss2portal.solid = SOLID_TRIGGER;
	boss2portal.effects = EF_NODRAW;
	boss2portal.map = "hub3";
	if (!boss2portal.wait)
		boss2portal.wait = 1;
	setsize(boss2portal, '-32 -32 -64', '32 32 64');
	boss2portal.think = portal_level_to_hub_active_wait;
	boss2portal.nextthink = time;
};

void()boss2_teleport_stage2;

void() boss_guardian2 =
{
   // precache_monster_boss1();
	precache_model("models/portals/portal_level_to_hub.md3");

	setmodel(self,"models/enemies/boss2/boss2.md3");
	self.classname = "boss_guardian2";
	setsize (self,'-100 -100 -192','100 100 192');
	self.health = boss2_healtha;
	self.movetype = MOVETYPE_FLY;
	//self.takedamage = DAMAGE_AIM;
	self.scale = 1.5;
	self.solid = SOLID_BBOX;
	self.bloody = 2;
	self.yaw_speed = 15;
	self.glowmod = '0.05 0.05 0.05';
	self.think = guardian2_idle;
	self.th_die = boss2_teleport_stage2;
	self.use = toggle_use;	
	self.nextthink = time + 0.1;
	entity nodrawcontroller = spawn();
	nodrawcontroller.owner = self;
	nodrawcontroller.origin = self.origin;
	setmodel(nodrawcontroller,"");
	nodrawcontroller.think = nodrawcontroller_think;
	nodrawcontroller.nextthink = time;

	//
	static void() shieldent_update = {
		self.frame = self.owner.frame;
		self.think = shieldent_update;
		self.nextthink = time + 0.01;
	};
	entity shieldent = spawn();
	setmodel(shieldent, "models/enemies/boss2/boss2.md3");
	shieldent.skin = 5;
	shieldent.owner = self;
	shieldent.think = shieldent_update;
	shieldent.nextthink = time + 0.01;
	setattachment(shieldent, self, "");
};

void() searchboss2 =
{
	entity boss2 = find(world, classname, "boss_guardian2");
	if(boss2)
	{
		self.owner = boss2;
	}
	vector org = self.origin; 
	string shieldmodel = "models/artifacts/effects/trinket_dome.md3";
	entity shield = spawn();
	shield.owner = self;
	shield.frame = 2;
	shield.alpha = 0.05;
	//shield.pflags = 129;
	shield.colormod = '2 0.2 2';
	shield.color = '1 0.3 1';
	shield.touch = orb_touch;
	shield.scale = 0.1;
	setmodel(shield, shieldmodel);
	vector posoffset = '0 0 512';
	posoffset_z += 	self.lip;
	setorigin(shield, org - posoffset);
	shield.solid = SOLID_TRIGGER;
	shield.nextthink = time + 0.05;
	shield.think = scale_shield;
};

void()boss2_teleport_stage2;

void()func_crystal_boss_use = 
{
	if(self.colormod_x > 0.20)
	{
		//self.effects = EF_DOUBLESIDED;
		self.colormod_x -= 0.01; 
		self.colormod_y = self.colormod_x  * 1.214285714; 
		if(self.colormod_y > 1)
		self.colormod_y = 1;	
		self.colormod_z = self.colormod_x; 
		self.think = func_crystal_boss_use;
		//self.pipes.light_lev = 128 * self.colormod_x;
        self.glowmod = self.colormod;
	}
	else
	{
		self.TrinketofRespite = 0;
		self.owner.bosscnt ++;
		if(self.owner.bosscnt >= 3)
			self.owner.takedamage = DAMAGE_AIM;
		self.owner.frame = $boss2_teleportb;
		self.owner.nextthink = time  + 1.5;
		if(self.owner.bosscnt >= 3)	
			self.owner.think = boss2_teleport_stage2;
		else
			self.owner.think = guardian2_paina;
		//remove(self.pipes);
		self.think = SUB_Null;
		self.nextthink = time;
		return;
	}
	self.nextthink = time + 0.02;
};

void()func_crystal_boss =
{
	self.solid = SOLID_BSP;
	self.colormod = '1 1 1';
	self.glowmod = '1 1 1';
	self.effects = EF_DOUBLESIDED + EF_NOSHADOW;
	self.alpha = 1;
	self.TrinketofRespite = 1;
	self.use = func_crystal_boss_use;
	/*entity olight = spawn();
	olight.origin = self.origin - '0 0 256';
	olight.pflags = 193;
	olight.color = '1.3 0.15 1.15';
	olight.style = 1;
	olight.light_lev = 600;
	self.pipes = olight;*/
    setmodel(self,self.model);
	self.think = searchboss2;
	self.nextthink = time + random(0.5,1);
};

.float boss2attack;

void() guardian2_controller_fly_loop =
{	
	if(self.owner.boss2attack > 0)
	{
		if(self.owner.speed2 > 0)			
			self.owner.speed2 = self.owner.speed2 * 0.85;
	}
	else
	{
		if(self.owner.speed2 < 2.5)			
			self.owner.speed2 = self.owner.speed2 * 1.025;
	}

	/*else
	{
		if(self.owner.takenflytime < time)
		{
			if(self.owner.speed2 > 0.3)			
				self.owner.speed2 -= 0.0125;

		}
		else
		{
			if(self.owner.speed2 < 2)
				self.owner.speed2 += 0.0125;
		}
	}*/
	self.owner.velocity = self.owner.dest * (boss2_speed * 0.5 * self.owner.speed2);
	if((self.owner.origin_z < single_player.origin_z)) 
	{
	
			self.owner.velocity_z = 32;
	}
	else
	{
		if((self.owner.origin_z > single_player.origin_z)  && ((self.owner.origin_z - single_player.origin_z) > 64) && ((self.owner.origin_z - self.owner.ldorigin_z) < 192))
			self.owner.velocity_z = -32;
		else
			self.owner.velocity_z = 0;
	}
	float speed = vlen(self.owner.velocity);
	entity oself = self;
	self = self.owner;
	ai_face();
	self = oself;
	self.think = guardian2_controller_fly_loop;
	self.nextthink = time + 0.05;
};

void(vector a, vector b) CastLightning = {};

void() stage2_idle;

void()stage2_preidle;



.vector boss2desta;
.vector boss2destb;
.vector boss2destc;

void() stage2_attack = 
{
	if(self.ammo_shotgun > 0)
	{
		if(!self.spawnedcrystal)
		{

			self.beam_counter = 0;
			self.beam_counter_view = 0;
			self.spawnedcrystal = 1;
			/*te_crystal(self);
			te_crystal(self);
			te_crystal(self);*/
			te_crystal2(self.origin, self.enemy.origin,60,0.25,0.25,5,world,self.enemy.origin);
		}
		if(self.ammo_shotgun <= 5)
			CastLightning();
		self.think = stage2_attack;
		self.ammo_shotgun --;
	}
	else
	{
		self.think = stage2_preidle;
		self.spawnedcrystal = 0;
	}
	self.nextthink = time + 0.1;
};

void() stage2_preattacka = 
{
	entity muzzle = spawn();
	muzzle.owner = self;
	setmodel (muzzle,"models/projectiles/proj_wretch.md3");
	setattachment (muzzle,self,"tag_chest");
	muzzle.scale = 3;
	muzzle.colormod = '0.9 0 0.75';
	muzzle.think = SUB_Remove;
	muzzle.nextthink = time + 0.75;
	self.think = stage2_attack;
	self.nextthink = time + 0.5;
};

.float lightningtime;

void(vector p1, vector p2, entity from, float damage) LightningDamage =
{

	local entity		e1, e2;
	local vector		f;
	f = p2 - p1;
	normalize (f);
	f_x = 0 - f_y;
	f_y = f_x;
	f_z = 0;
	f = f*16;
	e1 = e2 = world;
	traceline (p1, p2, FALSE, self);

	float r2 = random();

	if(r2 < 0.5)
	{	

		entity muzzle = spawn();
		setmodel (muzzle,"models/projectiles/proj_wretch.md3");
		setorigin(muzzle,trace_endpos);
		muzzle.scale = 0.3;
		muzzle.colormod = '0.9 0 0.75';
		muzzle.think = SUB_Remove;
		muzzle.nextthink = time + 0.75;

		sound7 (self, CHAN_AUTO, "weapons/crystal/crystalise.ogg", 1, 0.25,random(150,200),0);
		sound7 (self, CHAN_AUTO, "fx/tele4.ogg", 1, 0.5,random(150,200),0);
		if(r2 < 0.25)
		{
		te_customflash ( trace_endpos,92,1,'0.9 0 0.75');
		spawn_relevelation_particles(trace_endpos,7,'0.8 0.25 0.75',1);
		sound7 (self, CHAN_AUTO, "fx/tele3.ogg", 1, 0.5,random(150,200),0);
		}
		if(r2 < 0.1)
		sound7 (self, CHAN_AUTO, "fx/tele2.ogg", 1, 0.5,random(150,200),0);

	}
	pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
	if (trace_ent.takedamage)
	{
		vector dorg = p2; // + trace_endpos) * 0.5;
		pointparticles(particleeffectnum("crystal_impact3"), dorg, '0 0 0', 1);
		SpawnBlood(dorg, '0 0 0', 10, 1, 0);
		pointparticles(particleeffectnum("crystal_impact1"), dorg, '0 0 0', 1);
		T_Damage (trace_ent, from, from, damage);
		if (self.classname == "player")
		{
			if (other.classname == "player")
				trace_ent.velocity_z = trace_ent.velocity_z + 400;
		}

	}
	e1 = trace_ent;
	traceline (p1 + f, p2 + f, FALSE, self);
	if (trace_ent != e1 && trace_ent.takedamage)
	{
		pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
		T_Damage (trace_ent, from, from, damage);
	}
	e2 = trace_ent;
	traceline (p1 - f, p2 - f, FALSE, self);
	if (trace_ent != e1 && trace_ent != e2 && trace_ent.takedamage)
	{
		pointparticles(particleeffectnum("crystal_impact3"), trace_endpos, '0 0 0', 1);
		T_Damage (trace_ent, from, from, damage);
	}
};


void()stage2_teleportobeam;


void() lightningboss2think =
{

	vector tagorg = tag_origin("tag_chest", self.owner);
	vector org = tagorg;
	makevectors2(self.owner.angles);
	vector dir = (single_player.origin + '0 0 8')  + v_forward * 16;
	traceline (org, dir, FALSE, self);
	dir = trace_endpos;
	vector beamangle = vectoangles(dir - org);
	//beamangle_x *= -1;

    WriteByte(MSG_BROADCAST, SVC_TEMPENTITY);
    WriteByte(MSG_BROADCAST, TEMPENT::BOSS_BEAM);
    WriteVectorL(MSG_BROADCAST, org);
    WriteVectorL(MSG_BROADCAST, dir);
    WriteByte16(MSG_BROADCAST, 2); // beam scale
    WriteShort(MSG_BROADCAST, num_for_edict(self.owner)); // `self` meaning the entity that owns the beam
    WriteByte(MSG_BROADCAST, TRUE); // if the beam hit something, which makes the color slightly brighter


	if(self.owner.vweaponframe >= 10)
		self.think = SUB_Remove;
	else
		self.think = lightningboss2think;
	self.nextthink = time  + 0.001;
};
void() stage2_beamattack =
{
	if((self.vweaponframe >= 7) && (self.vweaponframe < 8))
	{
		self.frame += 0.075;
		self.vweaponframe += 0.075;	
	}
	else
	{
		self.frame += 1;
		self.vweaponframe += 1;	
	}
	ai_face_boss();
	

	if(self.vweaponframe == 6)
	{
		entity muzzle = spawn();
		muzzle.owner = self;
		setmodel (muzzle,"models/projectiles/proj_wretch.md3");
		setattachment (muzzle,self,"tag_chest");
		muzzle.scale = 3;
		muzzle.colormod = '0.9 0 0.75';
		muzzle.think = SUB_Remove;
		muzzle.nextthink = time + 0.75;
	}
	if(self.vweaponframe == 7)
	{
		entity lightningboss2 = spawn();
		lightningboss2.owner = self;
		lightningboss2.think = lightningboss2think;
		lightningboss2.nextthink = time;
	}
	if((self.vweaponframe >= 7) && (self.vweaponframe < 10))
	{
		if(self.glowmod_x > 0.1)
			self.glowmod_x -= 0.25;
		self.glowmod_y = self.glowmod_x;
		self.glowmod_z = self.glowmod_x;

		if(!self.spawnedcrystal)
		{

			self.beam_counter = 0;
			self.beam_counter_view = 0;
			self.spawnedcrystal = 1;

		}
		vector tagorg = tag_origin("tag_chest", self);
		vector org = tagorg;
		makevectors2(self.angles);
		vector dir = (single_player.origin + '0 0 8')  + v_forward * 16;
		traceline (org, dir, FALSE, self);
		dir = trace_endpos;
		vector beamangle = vectoangles(dir - org);
			LightningDamage(org,dir,self,boss2_beamdamage);

		float r2 = random();
		if(r2 < 0.5)
			te_customflash ( tagorg,92,1,'0.9 0 0.75');
	}

	if(self.vweaponframe >= 10)
		sound(self,CHAN_WEAPON,"sound/misc/null.wav",1,1);
	if(self.vweaponframe >= 20)
	{
		self.spawnedcrystal = 0;
		self.ammo_revolver --;
		self.glowmod = '0.05 0.05 0.05';
		if(self.ammo_revolver <= 0)
		{
			self.think = stage2_preidle;
			self.glowmod = '0.05 0.05 0.05';
			self.attack_finished = time + random(3,7);
		}
		else
		self.think = stage2_teleportobeam;

		self.nextthink = time  + 0.05;
	}
	else
	{
		self.think = stage2_beamattack;
		self.nextthink = time  + 0.1;
	}
};


void() stage2_prebeamattack =
{
	if(self.ammo_revolver > 0)
	{
		if(self.glowmod_x < 1.5)
			self.glowmod_x += 0.025;
		self.glowmod_y = self.glowmod_x;
		self.glowmod_z = self.glowmod_x;
	}
	if((self.glowmod_x >= 1.5) ||(self.ammo_revolver <= 0))
	{
		self.think = stage2_beamattack;
		self.frame = $boss2_attackc1;

	{
		string string_sound = "weapons/crystal/crystallizer_fire1.ogg";
		float r = random();
		if (r < 0.8)
			string_sound = "weapons/crystal/crystallizer_fire2.ogg";
		if (r < 0.6)
			string_sound = "weapons/crystal/crystallizer_fire3.ogg";
		if (r < 0.4)
			string_sound = "weapons/crystal/crystallizer_fire4.ogg";
		if (r < 0.2)
			string_sound = "weapons/crystal/crystallizer_fire5.ogg";

    	float wvol = cvar ("weapons_fire_volume");

		sound7(self,CHAN_AUTO,string_sound,wvol,0.25,80,0);
		sound7(self,CHAN_AUTO,string_sound,wvol,0.25,150,0);
		sound(self,CHAN_WEAPON,"weapons/crystal/crystallizer_fire_loop.ogg",wvol,0.25);
	}

	}
	else
		self.think = stage2_prebeamattack;



	self.nextthink = time  + 0.025;
};


void() stage2_teleportobeam =
{
	self.glowmod = '0.05 0.05 0.05';
	guardian2_teleport_effects(self);
	if(self.ammo_revolver == 3)
		setorigin(self,self.boss2desta);
	if(self.ammo_revolver == 2)
		setorigin(self,self.boss2destb);
	if(self.ammo_revolver == 1)
		setorigin(self,self.boss2destc);
	guardian2_teleport_effects(self);
		sound(self,CHAN_WEAPON,"sound/misc/null.wav",1,1);
	//if(self.ammo_revolver >= 1)
	{
		self.think = stage2_prebeamattack;
		self.frame = $boss2_idle40;
		self.vweaponframe = 1;
		entity muzzle = spawn();
		muzzle.owner = self;
		setmodel (muzzle,"models/projectiles/proj_wretch.md3");
		setattachment (muzzle,self,"tag_gem1");
		muzzle.scale = 0.3;
		muzzle.colormod = '0.9 0 0.75';
		muzzle.think = SUB_Remove;
		muzzle.nextthink = time + 0.75;
		entity muzzle2 = spawn();
		copyentity(muzzle,muzzle2);
		setattachment (muzzle,self,"tag_gem2");
		entity muzzle3 = spawn();
		copyentity(muzzle,muzzle3);
		setattachment (muzzle,self,"tag_gem3");
		entity muzzle4 = spawn();
		copyentity(muzzle,muzzle4);
		setattachment (muzzle,self,"tag_gem4");
	}	

	if(self.ammo_revolver >= 1)
	{
		self.think = stage2_prebeamattack;
		self.frame = $boss2_idle40;
	}

	if(self.ammo_revolver >= 1)
		self.nextthink = time + 0.75;
	else
		self.nextthink = time + 0.05;

};

void() stage2_preteleportobeam =
{

	if(self.lefty == 1)
	{
		self.boss2desta = self.pipes.enemy.enemy.origin;
		self.boss2destb = self.pipes.enemy.enemy.enemy.enemy.origin;
		self.boss2destc = self.pipes.enemy.enemy.enemy.enemy.enemy.enemy.origin;
		self.lefty = 0;
	}
	else
	{
		self.boss2desta = self.pipes.oldenemy.oldenemy.origin;
		self.boss2destb = self.pipes.oldenemy.oldenemy.oldenemy.oldenemy.origin;
		self.boss2destc = self.pipes.oldenemy.oldenemy.oldenemy.oldenemy.oldenemy.oldenemy.origin;
		self.lefty = 1;
	}

/*	entity sor, sor1,sor2;
	sor = spawn();
	sor.origin = self.boss2desta;
	sor.effects = 512;
	sor.scale = 10;
	sor.colormod = '1 0 0';
	setmodel(sor,"sorete");
	sor1 = spawn();
	sor1.origin = self.boss2destb;
	sor1.effects = 512;
	sor1.scale = 10;
	sor1.colormod = '0 1 0';
	setmodel(sor1,"sorete");
	sor2 = spawn();
	sor2.origin = self.boss2destc;
	sor2.effects = 512;
	sor2.scale = 10;
	sor2.colormod = '0 0 1';
	sor.think = SUB_Remove;
	sor1.think = SUB_Remove;
	sor2.think = SUB_Remove;
	sor.nextthink = time + 3;
	sor1.nextthink =  time + 6;
	sor2.nextthink =  time + 9;

	setmodel(sor2,"sorete");*/


	self.ammo_revolver = 3;
	self.frame = $boss2_teleportc;
	self.think = stage2_teleportobeam;
	self.nextthink = time + 0.5;

};


void() stage2_attackfan =
{

	ai_face_boss();
	if(self.vweaponframe < 12)
		self.ammo_cannon = 10;
		
	if(self.vweaponframe == 20)
	{

		if(self.ammo_cannon == 10)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 9)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 8)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 7)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 6)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 5)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 4)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 3)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 2)
			guardian2_attack_spread("tag_chest", 0,0);
		if(self.ammo_cannon == 1)
			guardian2_attack_spread("tag_chest", 0,0);
		self.ammo_cannon --;


		if(self.ammo_cannon <= 0)
		{
			self.frame ++;
			self.vweaponframe ++;
			self.nextthink = time  + 0.25;
		}
		else
		{
			self.frame = $boss2_attacka18;
			self.vweaponframe = 20;
			self.nextthink = time  + (self.ammo_cannon * 0.05);
		}
		self.think = stage2_attackfan;
		return;
	}

	else
	{
			self.frame ++;
			self.vweaponframe ++;

	}

	if(self.vweaponframe >= 22)
	{
		self.attack_finished = time + 2 + random(2);
		self.think = stage2_preteleportobeam;
		self.nextthink = time  + 0.1;

	}
	else
	{
		self.think = stage2_attackfan;
		self.nextthink = time  + 0.1;
	}

};

.float boss2_changedirectiontime;

void() stage2_idle =
{

	self.frame ++;
	if(self.frame >= $boss2_idle40)
		self.frame = $boss2_idle1;

	float isivisble = visible(self.enemy);
	if((self.attack_finished < time) && (isivisble == 1)&&  (!(self.enemy.flags &FL_NOTARGET)))
	{
		self.attack_finished = time + 5 + random(5);
		self.boss2attack = 1;
		self.magnetized = 0;
		self.frame = $boss2_attacka1;
		self.vweaponframe = 1;
		self.glowmod = '0.05 0.05 0.05';
		self.think = stage2_attackfan;
		/*float r = random();
		if((r > 0.5) && (self.boss2_changedirectiontime < time) && (isivisble != 1))
		{
			if(self.lefty == 1)
				self.lefty = 0;
			else
				self.lefty = 1;
			self.boss2_changedirectiontime = time + random (3,7);
		}*/
	}
	else
	{
		self.think = stage2_idle;
	}
	self.nextthink = time + 0.1;
};

void() stage2_preidle =
{
	self.glowmod = '0.05 0.05 0.05';
	self.speed2 = 0.75;
	self.frame = $boss2_hovera;
	self.boss2attack = 0;
	self.think = stage2_idle;
	self.nextthink = time + 0.05;
};

void() sorthink =
{
	vector tagorg = tag_origin("tag_chest", self.owner);
	setorigin (self,tagorg);
	vector ang = normalize (self.owner.enemy.origin - self.origin);
	self.angles = vectoangles(ang);
	self.think = sorthink;
	self.nextthink = time + 0.0125;
};

void() boss2_stage2 =
{
	setmodel(self,"models/enemies/boss2/boss2.md3");
	setsize (self,'-100 -100 -192','100 100 224');
	self.classname = "boss_guardian2";
	self.health = boss2_healtha;
	self.movetype = MOVETYPE_FLY;
	self.takedamage = DAMAGE_AIM;
	bossvulnerable = 1;
	self.scale = 1.5;
	self.effects = 0;
	self.solid = SOLID_BBOX;
	self.yaw_speed = 30;
	self.enemy = single_player;
	self.th_die = boss_guardian2_die;
	self.think = stage2_preidle;
	self.nextthink = time;
	entity controller = spawn();
	controller.speed2 = 1;
	controller.owner = self;
	controller.think = guardian2_controller_fly_loop;
	controller.nextthink = time + 0.1;
	world.episode = 2;
};

void()boss2_player_destination ={};
void()boss2_teleport_destination ={};

void()boss2_prestage2 = 
{
	entity destination = find(world, classname, "boss2_player_destination");
	guardian2_teleport_effects(self);
	entity oself = self;
	self = single_player;
	spawn_tfog(self.origin);
	local float v;
	local string tmpstr;
	v = random() *5;
	if (v < 1)
		tmpstr = "fx/tele1.ogg";
	else if (v < 2)
		tmpstr = "fx/tele2.ogg";
	else if (v < 3)
		tmpstr = "fx/tele3.ogg";
	else if (v < 4)
		tmpstr = "fx/tele4.ogg";
	else
		tmpstr = "fx/tele5.ogg";
	sound(self, CHAN_AUTO, tmpstr, 1, 0.25);
	self.velocity = '0 0 0';
	self.stoptime = time +1;
	self.lungefree = time + 1;
	if(!(self.flags & FL_IGNOREINPUT))
		self.flags += FL_IGNOREINPUT;
	self.hardstoptime = self.stoptime;
	setorigin (self, destination.origin);
	self.angles = destination.angles;
 	stuffcmd (self, "bf 0.95 0.95 1 0.9 0.45\n");
	spawn_tfog(destination.origin);
	self = oself;
	self.classname = "boss_guardian2";
	self.health = boss2_healtha;
	self.movetype = MOVETYPE_FLY;
	self.takedamage = DAMAGE_AIM;
	bossvulnerable = 1;
	self.effects = 0;
	self.solid = SOLID_BBOX;
	self.yaw_speed = 30;
	self.enemy = single_player;
	self.th_die = boss_guardian2_die;
	self.think = stage2_preidle;
	self.nextthink = time;
	self.glowmod = '0.05 0.05 0.05';
	entity controller = spawn();
	controller.speed2 = 1;
	controller.owner = self;
	controller.think = guardian2_controller_fly_loop;
	controller.nextthink = time + 0.1;
	self.attack_finished = time + 5 + random(5);
};

void() boss2_teleport_stage2 =
{

	guardian2_teleport_effects(self);
	entity destination = find(world, classname, "boss2_teleport_destination");
	setorigin (self, destination.origin);
	self.angles = destination.angles;
	spawn_shaker(self,32,1.25,768);  
	te_customflash (self.origin,512,0.55,'0.9 0.9 1');
	self.takedamage = 0;
	self.solid = 0;
	self.effects = EF_NODRAW;
	self.movetype = MOVETYPE_FLY;
	self.velocity = '0 0 0';
	self.avelocity = '0 0 0';	
	self.think = boss2_prestage2;
	self.ldorigin = destination.origin;
	self.nextthink = time + 1;
	self.vweapon = spawn();
	setmodel (self.vweapon,"models/enemies/boss2/vweapon.md3");
	vector tagorg = tag_origin("tag_chest", self);
	setorigin (self.vweapon,tagorg);
	self.vweapon.owner = self;
	self.vweapon.think = sorthink;
	self.vweapon.nextthink = time;
};



/* #endregion */
#endif
